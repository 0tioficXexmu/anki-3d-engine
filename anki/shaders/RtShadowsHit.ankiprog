// Copyright (C) 2009-2020, Panagiotis Christopoulos Charitos and contributors.
// All rights reserved.
// Code licensed under the BSD License.
// http://www.anki3d.org/LICENSE

#pragma anki library RtShadows
#pragma anki ray_type 0

#pragma anki mutator ALPHA_TEXTURE 0 1

#include <anki/shaders/Common.glsl>
#include <anki/shaders/include/GpuModel.h>

#if ALPHA_TEXTURE == 1
layout(set = 0, binding = 0, scalar) buffer b_ankiModels
{
	GpuModel u_ankiModels[];
};

layout(set = 0, binding = 1) uniform sampler u_ankiGlobalSampler;

ANKI_BINDLESS_SET(1);
#endif

#pragma anki start ahit

layout(location = 0) rayPayloadInEXT F32 g_payload;

hitAttributeEXT vec2 g_attribs;

ANKI_REF(U16Vec3, 2);
ANKI_REF(GpuVertex, 4);

void main()
{
#if ALPHA_TEXTURE == 1
	const GpuModel model = u_ankiModels[nonuniformEXT(gl_InstanceID)];
	const GpuMesh mesh = model.m_mesh;

	const U32 offset = gl_PrimitiveID * ANKI_SIZEOF(U16Vec3);
	const U16Vec3 indices = U16Vec3Ref(nonuniformEXT(mesh.m_indexBufferPtr + offset)).m_value;

	const GpuVertex vert0 = GpuVertexRef(mesh.m_vertexBufferPtr + indices[0] * ANKI_SIZEOF(GpuVertex)).m_value;
	const GpuVertex vert1 = GpuVertexRef(mesh.m_vertexBufferPtr + indices[1] * ANKI_SIZEOF(GpuVertex)).m_value;
	const GpuVertex vert2 = GpuVertexRef(mesh.m_vertexBufferPtr + indices[2] * ANKI_SIZEOF(GpuVertex)).m_value;

	const Vec3 barycentrics = Vec3(1.0f - g_attribs.x - g_attribs.y, g_attribs.x, g_attribs.y);

	const Vec2 uv = vert0.m_uvs[UV_CHANNEL_0] * barycentrics.x + vert1.m_uvs[UV_CHANNEL_0] * barycentrics.y
					+ vert2.m_uvs[UV_CHANNEL_0] * barycentrics.z;

	const U32 texIdx = model.m_material.m_textureIds[TEXTURE_CHANNEL_DIFFUSE];
	const F32 alpha = textureLod(u_bindlessTextures2dF32[nonuniformEXT(texIdx)], u_ankiGlobalSampler, uv, 3).a;

	g_payload += alpha;

	if(g_payload >= 1.0)
	{
		terminateRayEXT();
	}
#else
	g_payload = 1.0;
	terminateRayEXT();
#endif
}
#pragma anki end

#pragma anki start chit
void main()
{
}
#pragma anki end
