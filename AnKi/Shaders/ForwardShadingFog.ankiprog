// Copyright (C) 2009-2022, Panagiotis Christopoulos Charitos and contributors.
// All rights reserved.
// Code licensed under the BSD License.
// http://www.anki3d.org/LICENSE

#pragma anki mutator ANKI_TECHNIQUE 3

#include <AnKi/Shaders/ForwardShadingCommon.hlsl>
#include <AnKi/Shaders/Functions.hlsl>

#pragma anki reflect AnKiLocalUniforms
#pragma anki struct AnKiLocalUniforms
#pragma anki member RVec3 m_fogColor
#pragma anki member RF32 m_fogAlphaScale
#pragma anki member RF32 m_fogDistanceOfMaxThikness
#pragma anki struct end

[[vk::binding(kMaterialBindingGlobalUniforms, kMaterialSetGlobal)]] ConstantBuffer<MaterialGlobalUniforms>
	g_globalUniforms;
[[vk::binding(kMaterialBindingRenderableGpuView, kMaterialSetLocal)]] StructuredBuffer<RenderableGpuView>
	g_renderableGpuViews;
[[vk::binding(kMaterialBindingLocalUniforms, kMaterialSetLocal)]] ByteAddressBuffer g_localUniforms;

struct VertOut
{
	Vec4 m_svPosition : SV_POSITION;
	[[vk::location(0)]] F32 m_zVSpace : ZVSPACE;
};

#pragma anki start vert

VertOut main([[vk::location(VertexStreamId::kParticlePosition)]] Vec3 vertPos : POSITION)
{
	VertOut output;

	const RenderableGpuView renderable = g_renderableGpuViews[0];
	const Vec3 worldPos = mul(renderable.m_worldTransform, Vec4(vertPos, 1.0));

	output.m_svPosition = mul(g_globalUniforms.m_viewProjectionMatrix, Vec4(worldPos, 1.0));

	const Vec3 viewPos = mul(g_globalUniforms.m_viewTransform, Vec4(worldPos, 1.0));
	output.m_zVSpace = viewPos.z;

	return output;
}

#pragma anki end

#pragma anki start frag

FragOut main(VertOut input)
{
	FragOut output = (FragOut)0;
	const AnKiLocalUniforms localUniforms = loadAnKiLocalUniforms(g_localUniforms, 0u);

	fog(localUniforms.m_fogColor, localUniforms.m_fogAlphaScale, localUniforms.m_fogDistanceOfMaxThikness,
		input.m_svPosition, input.m_zVSpace, output);

	return output;
}
#pragma anki end
