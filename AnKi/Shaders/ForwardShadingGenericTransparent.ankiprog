// Copyright (C) 2009-2022, Panagiotis Christopoulos Charitos and contributors.
// All rights reserved.
// Code licensed under the BSD License.
// http://www.anki3d.org/LICENSE

#pragma anki hlsl

#pragma anki mutator ANKI_TECHNIQUE 3
#pragma anki mutator TEXTURE 0 1
#pragma anki mutator LIGHT 0 1

#include <AnKi/Shaders/ForwardShadingCommon.hlsl>
#include <AnKi/Shaders/Functions.hlsl>

#pragma anki reflect AnKiLocalUniforms
#pragma anki struct AnKiLocalUniforms
#pragma anki member U32 m_texture if TEXTURE is 1
#pragma anki member RVec4 m_colorScale
#pragma anki member RVec4 m_colorBias
#pragma anki struct end

[[vk::binding(kMaterialBindingGlobalUniforms, kMaterialSetGlobal)]] ConstantBuffer<MaterialGlobalUniforms>
	g_globalUniforms;
[[vk::binding(kMaterialBindingTrilinearRepeatSampler, kMaterialSetGlobal)]] SamplerState g_globalSampler;
[[vk::binding(kMaterialBindingLocalUniforms, kMaterialSetLocal)]] StructuredBuffer<U32> g_localUniforms;
[[vk::binding(kMaterialBindingRenderableGpuView, kMaterialSetLocal)]] StructuredBuffer<RenderableGpuView>
	g_renderableGpuViews;

struct VertIn
{
	[[vk::location(VertexStreamId::kPosition)]] Vec3 m_modelPos : POSITION;
	[[vk::location(VertexStreamId::kUv)]] Vec2 m_uv : TEXCOORD;
	U32 m_svInstanceId : SV_INSTANCEID;
};

struct VertOut
{
	[[vk::location(0)]] Vec2 m_uv : TEXCOORD;
	[[vk::location(1)]] Vec3 m_worldPosition : WORLD_POSITION;
	Vec4 m_svPosition : SV_POSITION;
};

#pragma anki start vert

VertOut main(VertIn input)
{
	VertOut output;

	output.m_worldPosition =
		mul(g_renderableGpuViews[input.m_svInstanceId].m_worldTransform, Vec4(input.m_modelPos, 1.0));

	output.m_svPosition = mul(g_globalUniforms.m_viewProjectionMatrix, Vec4(output.m_worldPosition, 1.0));

	output.m_uv = input.m_uv;

	return output;
}
#pragma anki end

#pragma anki start frag

FragOut main(VertOut input)
{
	ANKI_MAYBE_UNUSED(input);
	FragOut output;

	const AnKiLocalUniforms localUniforms = loadAnKiLocalUniforms(g_localUniforms, 0u);

	output.m_color = RVec4(1.0, 1.0, 1.0, 1.0);

#if TEXTURE == 1
	output.m_color = g_bindlessTextures2dF32[localUniforms.m_texture].Sample(g_globalSampler, input.m_uv);
#endif

#if LIGHT == 1
	output.m_color.rgb = computeLightColorLow(output.m_color.rgb, input.m_worldPosition, input.m_svPosition);
#endif

	output.m_color = output.m_color * localUniforms.m_colorScale + localUniforms.m_colorBias;

	return output;
}
#pragma anki end
