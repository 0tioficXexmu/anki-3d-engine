// Copyright (C) 2009-2021, Panagiotis Christopoulos Charitos and contributors.
// All rights reserved.
// Code licensed under the BSD License.
// http://www.anki3d.org/LICENSE

#pragma anki start comp

ANKI_SPECIALIZATION_CONSTANT_UVEC2(OUT_IMAGE_SIZE, 0, UVec2(1));
ANKI_SPECIALIZATION_CONSTANT_U32(MIN_SAMPLE_COUNT, 2, 1);
ANKI_SPECIALIZATION_CONSTANT_U32(MAX_SAMPLE_COUNT, 3, 1);
ANKI_SPECIALIZATION_CONSTANT_U32(MIN_PIXEL_RADIUS, 4, 1);
ANKI_SPECIALIZATION_CONSTANT_U32(MAX_PIXEL_RADIUS, 5, 1);
ANKI_SPECIALIZATION_CONSTANT_U32(SPIRAL_TURN_COUNT, 6, 1);

#include <AnKi/Shaders/BilateralFilter.glsl>
#include <AnKi/Shaders/Pack.glsl>
#include <AnKi/Shaders/RtShadows.glsl>

const UVec2 WORKGROUP_SIZE = UVec2(8u, 8u);
layout(local_size_x = WORKGROUP_SIZE.x, local_size_y = WORKGROUP_SIZE.y, local_size_z = 1) in;

layout(set = 0, binding = 0) uniform sampler u_nearestAnyClampSampler;
layout(set = 0, binding = 1) uniform sampler u_linearAnyClampSampler;
layout(set = 0, binding = 2) uniform utexture2D u_inTex;
layout(set = 0, binding = 3) uniform texture2D u_depthTex;
layout(set = 0, binding = 4) uniform texture2D u_gbuffer2Tex;
layout(set = 0, binding = 5) uniform texture2D u_momentsTex;
layout(set = 0, binding = 6) uniform texture2D u_historyLengthTex;
layout(set = 0, binding = 7) writeonly uniform uimage2D u_outImg;

layout(std430, push_constant, row_major) uniform b_pc
{
	RtShadowsDenoiseUniforms u_unis;
};

Vec3 unproject(Vec2 ndc, F32 depth)
{
	const Vec4 worldPos4 = u_unis.invViewProjMat * Vec4(ndc, depth, 1.0);
	const Vec3 worldPos = worldPos4.xyz / worldPos4.w;
	return worldPos;
}

F32 computeVarianceCenter(Vec2 uv)
{
	const F32 kernel[2][2] = {{1.0 / 4.0, 1.0 / 8.0}, {1.0 / 8.0, 1.0 / 16.0}};
	const I32 radius = 1;
	const Vec2 texelSize = 1.0 / Vec2(textureSize(u_momentsTex, 0).xy);
	Vec2 sumMoments = Vec2(0.0);

	for(I32 yy = -radius; yy <= radius; yy++)
	{
		for(I32 xx = -radius; xx <= radius; xx++)
		{
			const Vec2 newUv = uv + Vec2(xx, yy) * texelSize;
			const F32 k = kernel[abs(xx)][abs(yy)];
			sumMoments += textureLod(u_momentsTex, u_linearAnyClampSampler, newUv, 0.0).xy * k;
		}
	}

	return abs(sumMoments.y - sumMoments.x * sumMoments.x);
}

F32 computeShadowsLuma(F32 shadowLayers[MAX_RT_SHADOW_LAYERS])
{
	F32 l = 0.0;
	ANKI_UNROLL for(U32 i = 0; i < MAX_RT_SHADOW_LAYERS; ++i)
	{
		l += shadowLayers[i];
	}
	return min(1.0, l / 2.0);
}

void main()
{
	// Set UVs
	ANKI_BRANCH if(gl_GlobalInvocationID.x >= OUT_IMAGE_SIZE.x || gl_GlobalInvocationID.y >= OUT_IMAGE_SIZE.y)
	{
		// Out of bounds
		return;
	}

	const Vec2 uv = (Vec2(gl_GlobalInvocationID.xy) + 0.5) / Vec2(OUT_IMAGE_SIZE);

	// Reference
	const F32 depthCenter = textureLod(u_depthTex, u_linearAnyClampSampler, uv, 0.0).r;
	if(depthCenter == 1.0)
	{
		imageStore(u_outImg, IVec2(gl_GlobalInvocationID.xy), UVec4(0));
		return;
	}

	const Vec3 positionCenter = unproject(UV_TO_NDC(uv), depthCenter);
	const Vec3 normalCenter = readNormalFromGBuffer(u_gbuffer2Tex, u_linearAnyClampSampler, uv);

	F32 shadowFactors[MAX_RT_SHADOW_LAYERS];
	unpackRtShadows(textureLod(u_inTex, u_nearestAnyClampSampler, uv, 0.0), shadowFactors);

	// Decide the amount of blurring
	const F32 varianceCenter = computeVarianceCenter(uv);
	const F32 historyLength =
		textureLod(u_historyLengthTex, u_linearAnyClampSampler, uv, 0.0).x * RT_SHADOWS_MAX_HISTORY_LENGTH;

	U32 pixelRadius;
	U32 sampleCount;
	if(historyLength < 2.0)
	{
		// Worst case
		pixelRadius = MAX_PIXEL_RADIUS;
		sampleCount = MAX_SAMPLE_COUNT;
	}
	else if(historyLength > 4.0 && varianceCenter < 0.0001)
	{
		// Best case
		pixelRadius = MIN_PIXEL_RADIUS;
		sampleCount = MIN_SAMPLE_COUNT;
	}
	else
	{
		// Every other case

		F32 blur = varianceCenter * 100.0;
		blur = min(1.0, blur);

		const F32 pixelRadiusf = mix(F32(MIN_PIXEL_RADIUS), F32(MAX_PIXEL_RADIUS), blur);
		const F32 sampleCountf = mix(F32(MIN_SAMPLE_COUNT), F32(MAX_SAMPLE_COUNT), blur);

		pixelRadius = U32(pixelRadiusf);
		sampleCount = U32(sampleCountf);
	}

	// Sample
	SpatialBilateralContext ctx =
		spatialBilateralInit(sampleCount, gl_GlobalInvocationID.xy, pixelRadius, SPIRAL_TURN_COUNT, u_unis.time);
	F32 weight = 1.0;

	for(U32 i = 0; i < sampleCount; ++i)
	{
		const IVec2 unormalizedUvs = clamp(IVec2(spatialBilateralIterate(ctx, i)), IVec2(0), IVec2(OUT_IMAGE_SIZE - 1));
		const Vec2 sampleUv = Vec2(unormalizedUvs) / Vec2(OUT_IMAGE_SIZE);

		F32 localShadowFactors[MAX_RT_SHADOW_LAYERS];
		unpackRtShadows(texelFetch(u_inTex, IVec2(unormalizedUvs / 2), 0), localShadowFactors);

		const F32 depthTap = texelFetch(u_depthTex, unormalizedUvs, 0).r;
		const Vec3 positionTap = unproject(UV_TO_NDC(sampleUv), depthTap);
		const Vec3 normalTap = unpackNormalFromGBuffer(texelFetch(u_gbuffer2Tex, unormalizedUvs, 0));

		const F32 w = calculateBilateralWeightPlane(positionCenter, normalCenter, positionTap, normalTap, 1.0);

		ANKI_UNROLL for(U32 i = 0; i < MAX_RT_SHADOW_LAYERS; ++i)
		{
			shadowFactors[i] += localShadowFactors[i] * w;
		}

		weight += w;
	}

	// Write value
	ANKI_UNROLL for(U32 i = 0; i < MAX_RT_SHADOW_LAYERS; ++i)
	{
		shadowFactors[i] /= weight;
	}

	imageStore(u_outImg, IVec2(gl_GlobalInvocationID.xy), packRtShadows(shadowFactors));
}

#pragma anki end
