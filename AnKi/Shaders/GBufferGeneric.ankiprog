// Copyright (C) 2009-2022, Panagiotis Christopoulos Charitos and contributors.
// All rights reserved.
// Code licensed under the BSD License.
// http://www.anki3d.org/LICENSE

#pragma anki mutator ANKI_LOD 0 1 2
#pragma anki mutator ANKI_VELOCITY 0 1
#pragma anki mutator ANKI_TECHNIQUE 0 1 2
#pragma anki mutator ANKI_BONES 0 1
#pragma anki mutator DIFFUSE_TEX 0 1
#pragma anki mutator SPECULAR_TEX 0 1
#pragma anki mutator ROUGHNESS_TEX 0 1
#pragma anki mutator METAL_TEX 0 1
#pragma anki mutator NORMAL_TEX 0 1
#pragma anki mutator PARALLAX 0 1
#pragma anki mutator EMISSIVE_TEX 0 1
#pragma anki mutator ALPHA_TEST 0 1

#pragma anki rewrite_mutation ANKI_TECHNIQUE 1 DIFFUSE_TEX 1 ALPHA_TEST 0 to ANKI_TECHNIQUE 1 DIFFUSE_TEX 0 ALPHA_TEST 0
#pragma anki rewrite_mutation ANKI_TECHNIQUE 2 DIFFUSE_TEX 1 ALPHA_TEST 0 to ANKI_TECHNIQUE 2 DIFFUSE_TEX 0 ALPHA_TEST 0

#pragma anki rewrite_mutation ANKI_TECHNIQUE 1 SPECULAR_TEX 1 to ANKI_TECHNIQUE 1 SPECULAR_TEX 0
#pragma anki rewrite_mutation ANKI_TECHNIQUE 2 SPECULAR_TEX 1 to ANKI_TECHNIQUE 2 SPECULAR_TEX 0

#pragma anki rewrite_mutation ANKI_TECHNIQUE 1 NORMAL_TEX 1 to ANKI_TECHNIQUE 1 NORMAL_TEX 0
#pragma anki rewrite_mutation ANKI_TECHNIQUE 2 NORMAL_TEX 1 to ANKI_TECHNIQUE 2 NORMAL_TEX 0

#pragma anki rewrite_mutation ANKI_TECHNIQUE 1 ROUGHNESS_TEX 1 to ANKI_TECHNIQUE 1 ROUGHNESS_TEX 0
#pragma anki rewrite_mutation ANKI_TECHNIQUE 2 ROUGHNESS_TEX 1 to ANKI_TECHNIQUE 2 ROUGHNESS_TEX 0

#pragma anki rewrite_mutation ANKI_TECHNIQUE 1 METAL_TEX 1 to ANKI_TECHNIQUE 1 METAL_TEX 0
#pragma anki rewrite_mutation ANKI_TECHNIQUE 2 METAL_TEX 1 to ANKI_TECHNIQUE 2 METAL_TEX 0

#pragma anki rewrite_mutation ANKI_TECHNIQUE 1 EMISSIVE_TEX 1 to ANKI_TECHNIQUE 1 EMISSIVE_TEX 0
#pragma anki rewrite_mutation ANKI_TECHNIQUE 2 EMISSIVE_TEX 1 to ANKI_TECHNIQUE 2 EMISSIVE_TEX 0

#pragma anki rewrite_mutation ANKI_TECHNIQUE 1 PARALLAX 1 to ANKI_TECHNIQUE 1 PARALLAX 0
#pragma anki rewrite_mutation ANKI_TECHNIQUE 2 PARALLAX 1 to ANKI_TECHNIQUE 2 PARALLAX 0

#pragma anki rewrite_mutation ALPHA_TEST 1 DIFFUSE_TEX 0 to ALPHA_TEST 0 DIFFUSE_TEX 0

#include <AnKi/Shaders/GBufferCommon.glsl>

layout(set = MATERIAL_SET_EXTERNAL, binding = MATERIAL_BINDING_GLOBAL_SAMPLER) uniform sampler u_globalSampler;

#if DIFFUSE_TEX
#	pragma anki reflect u_diffTex
layout(set = MATERIAL_SET_EXTERNAL,
	   binding = MATERIAL_BINDING_FIRST_NON_STANDARD + 0u) uniform ANKI_RP texture2D u_diffTex;
#endif

#if SPECULAR_TEX
#	pragma anki reflect u_specTex
layout(set = MATERIAL_SET_EXTERNAL,
	   binding = MATERIAL_BINDING_FIRST_NON_STANDARD + 1u) uniform ANKI_RP texture2D u_specTex;
#endif

#if ROUGHNESS_TEX
#	pragma anki reflect u_roughnessTex
layout(set = MATERIAL_SET_EXTERNAL,
	   binding = MATERIAL_BINDING_FIRST_NON_STANDARD + 2u) uniform ANKI_RP texture2D u_roughnessTex;
#endif

#if NORMAL_TEX
#	pragma anki reflect u_normalTex
layout(set = MATERIAL_SET_EXTERNAL,
	   binding = MATERIAL_BINDING_FIRST_NON_STANDARD + 3u) uniform ANKI_RP texture2D u_normalTex;
#endif

#if METAL_TEX
#	pragma anki reflect u_metallicTex
layout(set = MATERIAL_SET_EXTERNAL,
	   binding = MATERIAL_BINDING_FIRST_NON_STANDARD + 4u) uniform ANKI_RP texture2D u_metallicTex;
#endif

#if PARALLAX
#	pragma anki reflect u_heightTex
layout(set = MATERIAL_SET_EXTERNAL,
	   binding = MATERIAL_BINDING_FIRST_NON_STANDARD + 5u) uniform ANKI_RP texture2D u_heightTex;
#endif

#if EMISSIVE_TEX
#	pragma anki reflect u_emissiveTex
layout(set = MATERIAL_SET_EXTERNAL,
	   binding = MATERIAL_BINDING_FIRST_NON_STANDARD + 6u) uniform ANKI_RP texture2D u_emissiveTex;
#endif

#pragma anki reflect AnKiLocalUniforms
struct AnKiLocalUniforms
{
#if !DIFFUSE_TEX
	Vec3 m_diffColor;
#endif
#if !ROUGHNESS_TEX
	F32 m_roughness;
#endif
#if !SPECULAR_TEX
	Vec3 m_specColor;
#endif
#if !METAL_TEX
	F32 m_metallic;
#endif
#if !EMISSIVE_TEX
	Vec3 m_emission;
#endif
#if PARALLAX
	F32 m_heightmapScale;
#endif

	F32 m_subsurface;
};

layout(set = MATERIAL_SET_EXTERNAL, binding = MATERIAL_BINDING_LOCAL_UNIFORMS, row_major,
	   scalar) uniform b_localUniforms
{
	AnKiLocalUniforms u_localUniforms;
};

layout(set = MATERIAL_SET_EXTERNAL, binding = MATERIAL_BINDING_RENDERABLE_GPU_VIEW, row_major,
	   scalar) uniform b_renderableGpuView
{
	RenderableGpuView u_renderableGpuViews[MAX_INSTANCE_COUNT];
};

layout(set = MATERIAL_SET_EXTERNAL, binding = MATERIAL_BINDING_GLOBAL_UNIFORMS, row_major,
	   scalar) uniform b_globalUniforms
{
	MaterialGlobalUniforms u_globalUniforms;
};

#if ANKI_BONES
#	pragma anki reflect b_boneTransforms
layout(set = MATERIAL_SET_EXTERNAL, binding = MATERIAL_BINDING_BONE_TRANSFORMS, row_major,
	   std140) readonly buffer b_boneTransforms
{
	Mat4 u_boneTransforms[];
};

#	pragma anki reflect b_prevFrameBoneTransforms
layout(set = MATERIAL_SET_EXTERNAL, binding = MATERIAL_BINDING_PREVIOUS_BONE_TRANSFORMS, row_major,
	   std140) readonly buffer b_prevFrameBoneTransforms
{
	Mat4 u_prevFrameBoneTransforms[];
};
#endif

#pragma anki start vert

// Globals (always in local space)
Vec3 g_position = in_position;
#if ANKI_TECHNIQUE == RENDERING_TECHNIQUE_GBUFFER
Vec3 g_prevPosition = in_position;
ANKI_RP Vec3 g_normal = in_normal;
ANKI_RP Vec4 g_tangent = in_tangent;
#endif

#if ANKI_TECHNIQUE == RENDERING_TECHNIQUE_GBUFFER || ALPHA_TEST
Vec2 g_uv = in_uv;
#endif

// Perform skinning
#if ANKI_BONES
void skinning()
{
	ANKI_RP Mat4 skinMat = u_boneTransforms[in_boneIndices[0]] * in_boneWeights[0];
	ANKI_RP Mat4 prevSkinMat = u_prevFrameBoneTransforms[in_boneIndices[0]] * in_boneWeights[0];
	ANKI_UNROLL for(U32 i = 1u; i < 4u; ++i)
	{
		skinMat += u_boneTransforms[in_boneIndices[i]] * in_boneWeights[i];
		prevSkinMat += u_prevFrameBoneTransforms[in_boneIndices[i]] * in_boneWeights[i];
	}

#	if ANKI_TECHNIQUE == RENDERING_TECHNIQUE_GBUFFER
	g_prevPosition = (prevSkinMat * Vec4(g_position, 1.0)).xyz;
	g_tangent.xyz = (skinMat * Vec4(g_tangent.xyz, 0.0)).xyz;
	g_normal = (skinMat * Vec4(g_normal, 0.0)).xyz;
#	endif

	g_position = (skinMat * Vec4(g_position, 1.0)).xyz;
}
#endif

// Common store function
#if ANKI_TECHNIQUE == RENDERING_TECHNIQUE_GBUFFER
void positionUvNormalTangent()
{
	gl_Position = u_globalUniforms.m_viewProjectionMatrix
				  * Vec4(u_renderableGpuViews[gl_InstanceIndex].m_worldTransform * Vec4(g_position, 1.0), 1.0);
	out_normal = u_renderableGpuViews[gl_InstanceIndex].m_worldRotation * g_normal;
	out_tangent = u_renderableGpuViews[gl_InstanceIndex].m_worldRotation * g_tangent.xyz;
	out_bitangent = cross(out_normal, out_tangent) * g_tangent.w;
	out_uv = g_uv;
}
#endif

// Store stuff for parallax mapping
#if REALLY_USING_PARALLAX
void parallax()
{
	const Vec3 n = in_normal;
	const Vec3 t = in_tangent.xyz;
	const Vec3 b = cross(n, t) * in_tangent.w;

	const Mat3 invTbn = transpose(u_globalUniforms.m_viewRotationMatrix
								  * u_renderableGpuViews[gl_InstanceIndex].m_worldRotation * Mat3(t, b, n));

	const Vec3 viewPos = (u_globalUniforms.m_viewMatrix
						  * Vec4(u_renderableGpuViews[gl_InstanceIndex].m_worldTransform * Vec4(g_position, 1.0), 1.0))
							 .xyz;
	out_distFromTheCamera = viewPos.z;

	out_eyeTangentSpace = invTbn * viewPos;
	out_normalTangentSpace = invTbn * n;
}
#endif

#if(ANKI_VELOCITY || ANKI_BONES) && ANKI_TECHNIQUE == RENDERING_TECHNIQUE_GBUFFER
void velocity()
{
	const Vec3 prevLocalPos = g_prevPosition;

#	if ANKI_VELOCITY
	const Mat3x4 trf = u_renderableGpuViews[gl_InstanceIndex].m_previousWorldTransform;
#	else
	const Mat3x4 trf = u_renderableGpuViews[gl_InstanceIndex].m_worldTransform;
#	endif

	const Vec4 v4 = u_globalUniforms.m_viewProjectionMatrix * Vec4(trf * Vec4(prevLocalPos, 1.0), 1.0);

	const Vec2 prevNdc = v4.xy / v4.w;

	const Vec2 crntNdc = gl_Position.xy / gl_Position.w;

	// It's NDC_TO_UV(prevNdc) - NDC_TO_UV(crntNdc) or:
	out_velocity = (prevNdc - crntNdc) * 0.5;
}
#endif

void main()
{
#if ANKI_BONES
	skinning();
#endif

#if ANKI_TECHNIQUE == RENDERING_TECHNIQUE_GBUFFER
	positionUvNormalTangent();

#	if REALLY_USING_PARALLAX
	parallax();
#	endif

#	if ANKI_VELOCITY || ANKI_BONES
	velocity();
#	endif
#else
	gl_Position = u_globalUniforms.m_viewProjectionMatrix
				  * Vec4(u_renderableGpuViews[gl_InstanceIndex].m_worldTransform * Vec4(g_position, 1.0), 1.0);

#	if ALPHA_TEST
	out_uv = g_uv;
#	endif
#endif
}
#pragma anki end

#pragma anki start frag

#if REALLY_USING_PARALLAX
Vec2 computeTextureCoordParallax(texture2D heightMap, sampler sampl, Vec2 uv, F32 heightMapScale)
{
	const U32 MAX_SAMPLES = 25u;
	const U32 MIN_SAMPLES = 1u;
	const F32 MAX_EFFECTIVE_DISTANCE = 32.0;

	// Get that because we are sampling inside a loop
	const Vec2 dPdx = dFdx(uv);
	const Vec2 dPdy = dFdy(uv);

	const Vec3 eyeTangentSpace = in_eyeTangentSpace;
	const Vec3 normTangentSpace = in_normalTangentSpace;

	F32 parallaxLimit = -length(eyeTangentSpace.xy) / eyeTangentSpace.z;
	parallaxLimit *= heightMapScale;

	const Vec2 offsetDir = normalize(eyeTangentSpace.xy);
	const Vec2 maxOffset = offsetDir * parallaxLimit;

	const Vec3 E = normalize(eyeTangentSpace);

	const F32 factor0 = -dot(E, normTangentSpace);
	const F32 factor1 = in_distFromTheCamera / -MAX_EFFECTIVE_DISTANCE;
	const F32 factor = saturate((1.0 - factor0) * (1.0 - factor1));
	const F32 sampleCountf = mix(F32(MIN_SAMPLES), F32(MAX_SAMPLES), factor);

	const F32 stepSize = 1.0 / sampleCountf;

	F32 crntRayHeight = 1.0;
	Vec2 crntOffset = Vec2(0.0);
	Vec2 lastOffset = Vec2(0.0);

	F32 lastSampledHeight = 1.0;
	F32 crntSampledHeight = 1.0;

	U32 crntSample = 0u;

	const U32 sampleCount = U32(sampleCountf);
	ANKI_LOOP while(crntSample < sampleCount)
	{
		crntSampledHeight = textureGrad(heightMap, sampl, uv + crntOffset, dPdx, dPdy).r;

		if(crntSampledHeight > crntRayHeight)
		{
			const F32 delta1 = crntSampledHeight - crntRayHeight;
			const F32 delta2 = (crntRayHeight + stepSize) - lastSampledHeight;
			const F32 ratio = delta1 / (delta1 + delta2);

			crntOffset = mix(crntOffset, lastOffset, ratio);

			crntSample = sampleCount + 1u;
		}
		else
		{
			crntSample++;

			crntRayHeight -= stepSize;

			lastOffset = crntOffset;
			crntOffset += stepSize * maxOffset;

			lastSampledHeight = crntSampledHeight;
		}
	}

	return uv + crntOffset;
}
#endif

// Do normal mapping
#if ANKI_TECHNIQUE == RENDERING_TECHNIQUE_GBUFFER
ANKI_RP Vec3 readNormalFromTexture(ANKI_RP texture2D map, sampler sampl, highp Vec2 texCoords)
{
	// First read the texture
	const ANKI_RP Vec3 nAtTangentspace = normalize((texture(map, sampl, texCoords).rgb - 0.5) * 2.0);

	const ANKI_RP Vec3 n = normalize(in_normal);
	const ANKI_RP Vec3 t = normalize(in_tangent);
	const ANKI_RP Vec3 b = normalize(in_bitangent);

	const ANKI_RP Mat3 tbnMat = Mat3(t, b, n);

	return tbnMat * nAtTangentspace;
}
#endif

void doAlphaText(F32 alpha)
{
	if(alpha == 0.0)
	{
		discard;
	}
}

void main()
{
#if ANKI_TECHNIQUE == RENDERING_TECHNIQUE_GBUFFER
#	if REALLY_USING_PARALLAX
	const Vec2 uv = computeTextureCoordParallax(u_heightTex, u_globalSampler, in_uv, u_localUniforms.m_heightmapScale);
#	else
	const Vec2 uv = in_uv;
#	endif

#	if DIFFUSE_TEX
#		if ALPHA_TEST
	const ANKI_RP Vec4 diffColorA = texture(u_diffTex, u_globalSampler, uv);
	doAlphaText(diffColorA.a);
	const ANKI_RP Vec3 diffColor = diffColorA.rgb;
#		else
	const ANKI_RP Vec3 diffColor = texture(u_diffTex, u_globalSampler, uv).rgb;
#		endif
#	else
	const ANKI_RP Vec3 diffColor = u_localUniforms.m_diffColor;
#	endif

#	if SPECULAR_TEX
	const ANKI_RP Vec3 specColor = texture(u_specTex, u_globalSampler, uv).rgb;
#	else
	const ANKI_RP Vec3 specColor = u_localUniforms.m_specColor;
#	endif

#	if ROUGHNESS_TEX
	const ANKI_RP F32 roughness = texture(u_roughnessTex, u_globalSampler, uv).g;
#	else
	const ANKI_RP F32 roughness = u_localUniforms.m_roughness;
#	endif

#	if METAL_TEX
	const ANKI_RP F32 metallic = texture(u_metallicTex, u_globalSampler, uv).b;
#	else
	const ANKI_RP F32 metallic = u_localUniforms.m_metallic;
#	endif

#	if NORMAL_TEX
	const ANKI_RP Vec3 normal = readNormalFromTexture(u_normalTex, u_globalSampler, uv);
#	else
	const ANKI_RP Vec3 normal = normalize(in_normal);
#	endif

#	if EMISSIVE_TEX
	const ANKI_RP Vec3 emission = texture(u_emissiveTex, u_globalSampler, uv).rgb;
#	else
	const ANKI_RP Vec3 emission = u_localUniforms.m_emission;
#	endif

#	if ANKI_VELOCITY || ANKI_BONES
	const Vec2 velocity = in_velocity;
#	else
	const Vec2 velocity = Vec2(1.0);
#	endif

	packGBuffer(diffColor, normal, specColor, roughness, u_localUniforms.m_subsurface, emission, metallic, velocity);
#elif ANKI_TECHNIQUE == RENDERING_TECHNIQUE_GBUFFER_EZ
	out_gbuffer0 = Vec4(0.0);
	out_gbuffer1 = Vec4(0.0);
	out_gbuffer2 = Vec4(0.0);
	out_gbuffer3 = Vec2(0.0);
#endif

#if ANKI_TECHNIQUE != RENDERING_TECHNIQUE_GBUFFER && ALPHA_TEST
	doAlphaText(texture(u_diffTex, u_globalSampler, in_uv).a);
#endif
}

#pragma anki end
