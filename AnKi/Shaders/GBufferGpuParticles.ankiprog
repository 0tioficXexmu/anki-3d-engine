// Copyright (C) 2009-2022, Panagiotis Christopoulos Charitos and contributors.
// All rights reserved.
// Code licensed under the BSD License.
// http://www.anki3d.org/LICENSE

#pragma anki mutator ANKI_TECHNIQUE 0 1

#include <AnKi/Shaders/Include/ParticleTypes.h>
#include <AnKi/Shaders/Include/MaterialTypes.h>
#include <AnKi/Shaders/Include/GpuSceneTypes.h>
#include <AnKi/Shaders/Functions.hlsl>

#pragma anki reflect AnKiLocalUniforms
#pragma anki struct AnKiLocalUniforms
#pragma anki member RVec3 m_diffColor
#pragma anki member RF32 m_roughness
#pragma anki member RVec3 m_specColor
#pragma anki member RF32 m_metallic
#pragma anki member RVec3 m_initialEmission
#pragma anki member RVec3 m_finalEmission
#pragma anki struct end

[[vk::binding(kMaterialBindingLocalUniforms, kMaterialSetLocal)]] ByteAddressBuffer u_localUniforms;
[[vk::binding(kMaterialBindingRenderableGpuView, kMaterialSetLocal)]] StructuredBuffer<RenderableGpuView>
	u_renderableGpuViews;
[[vk::binding(kMaterialBindingGlobalUniforms, kMaterialSetGlobal)]] ConstantBuffer<MaterialGlobalUniforms>
	u_globalUniforms;
[[vk::binding(kMaterialBindingFirstNonStandardLocal, kMaterialSetLocal)]] StructuredBuffer<GpuParticle> u_particles;

struct VertIn
{
	U32 m_svVertexId : SV_VERTEXID;
};

struct VertOut
{
	Vec2 m_velocity : VELOCITY;
	nointerpolation RF32 m_lifeFactor : LIFE;
	nointerpolation RVec3 m_normal : NORMAL;
	Vec4 m_svPosition : SV_POSITION;
};

struct FragOut
{
	Vec4 m_color0 : SV_TARGET0;
	Vec4 m_color1 : SV_TARGET1;
	Vec4 m_color2 : SV_TARGET2;
	Vec2 m_color3 : SV_TARGET3;
};

#pragma anki start vert

VertOut main(VertIn input)
{
	VertOut output;
	const GpuParticle part = u_particles[input.m_svVertexId / 2];

	Vec4 crntClipPos = Vec4(mul(u_renderableGpuViews[0].m_worldTransform, Vec4(part.m_newWorldPosition, 1.0)), 1.0);
	crntClipPos = mul(u_globalUniforms.m_viewProjectionMatrix, crntClipPos);

	Vec4 prevClipPos = Vec4(mul(u_renderableGpuViews[0].m_worldTransform, Vec4(part.m_oldWorldPosition, 1.0)), 1.0);
	prevClipPos = mul(u_globalUniforms.m_viewProjectionMatrix, prevClipPos);

	output.m_svPosition = ((input.m_svVertexId & 1) == 0) ? crntClipPos : prevClipPos;

	const Vec2 crntNdc = crntClipPos.xy / crntClipPos.w;
	const Vec2 prevNdc = prevClipPos.xy / prevClipPos.w;

	// It's NDC_TO_UV(prevNdc) - NDC_TO_UV(crntNdc) or:
	output.m_velocity = ((input.m_svVertexId & 1) == 0) ? Vec2(0.0, 0.0) : (prevNdc - crntNdc) * 0.5;

	output.m_lifeFactor = saturate(1.0 - (part.m_life / part.m_startingLife));

	output.m_normal =
		normalize(Vec3(u_globalUniforms.m_cameraTransform.m_row0[2], u_globalUniforms.m_cameraTransform.m_row1[2],
					   u_globalUniforms.m_cameraTransform.m_row2[2]));

	return output;
}
#pragma anki end

#pragma anki start frag
#include <AnKi/Shaders/PackFunctions.hlsl>

FragOut main(VertOut input)
{
	FragOut output;
	const AnKiLocalUniforms localUniforms = loadAnKiLocalUniforms(u_localUniforms, 0u);

	GbufferInfo g;
	g.m_diffuse = localUniforms.m_diffColor;
	g.m_normal = input.m_normal;
	g.m_f0 = localUniforms.m_specColor;
	g.m_roughness = localUniforms.m_roughness;
	g.m_subsurface = 0.0;
	g.m_emission = lerp(localUniforms.m_initialEmission, localUniforms.m_finalEmission, input.m_lifeFactor);
	g.m_metallic = localUniforms.m_metallic;
	g.m_velocity = input.m_velocity;
	packGBuffer(g, output.m_color0, output.m_color1, output.m_color2, output.m_color3);
	return output;
}
#pragma anki end
