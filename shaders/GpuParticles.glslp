// Copyright (C) 2009-2019, Panagiotis Christopoulos Charitos and contributors.
// All rights reserved.
// Code licensed under the BSD License.
// http://www.anki3d.org/LICENSE

#pragma anki input const Vec3 diffColor
#pragma anki input const Vec3 specColor
#pragma anki input const F32 roughness
#pragma anki input const F32 metallic
#pragma anki input const Vec3 emission

layout(push_constant, row_major) pc_
{
	Mat4 u_mvp;
	Vec3 u_minusCameraZ;
	U32 u_particleCount;
};

layout(set = 0, binding = 0) buffer ssbo_
{
	GpuParticle u_particles[];
}

#pragma anki start vert

#include <shaders/glsl_cpp_common/GpuParticles.h>

layout(location = 0) flat out Vec2 out_velocity;

void main()
{
	const Particle part = u_particles[gl_VertexID / 2];

	const Vec4 clipPos = u_mvp * Vec4(part.m_newWorldPosition, 1.0);
	const Vec4 prevClipPos = u_mvp * Vec4(part.m_oldWorldPosition, 1.0);

	gl_Position = ((gl_VertexID & 1) == 0) ? clipPos : prevClipPos;

	const Vec2 crntNdc = clipPos.xy / clipPos.w;
	const Vec2 prevNdc = prevClipPos.xy / prevClipPos.w;

	// It's NDC_TO_UV(prevNdc) - NDC_TO_UV(crntNdc) or:
	out_velocity = (prevNdc - crntNdc) * 0.5;
}
#pragma anki end

#pragma anki start frag
#include <shaders/GBufferCommonFrag.glsl>

layout(location = 0) flat in Vec2 in_velocity;

void main()
{
	const Vec3 normal = u_minusCameraZ;
	writeRts(diffColor, normal, specColor, roughness, subsurface, emission, metallic, in_velocity);
}
#pragma anki end
