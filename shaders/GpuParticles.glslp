// Copyright (C) 2009-2019, Panagiotis Christopoulos Charitos and contributors.
// All rights reserved.
// Code licensed under the BSD License.
// http://www.anki3d.org/LICENSE

// This shader does a particle simulation

#pragma anki input const U32 WORKGROUP_SIZE_X

#pragma anki start comp

#include <shaders/glsl_cpp_common/GpuParticles.h>
#include <shaders/Common.glsl>

layout(local_size_x = WORKGROUP_SIZE_X, local_size_y = 1, local_size_z = 1) in;

layout(set = 0, binding = 0) uniform texture2D u_depthMap;

layout(set = 1, binding = 0) buffer ssbo_
{
	GpuParticle u_particles[];
};

layout(set = 1, binding = 1) buffer ubo_
{
	GpuParticleEmitterProperties u_props;
};

layout(set = 1, binding = 2) uniform texture2D u_noiseTex;
layout(set = 1, binding = 3) uniform sampler u_nearestAnyRepeatSampler;

layout(std140, push_constant) pc_
{
	Mat4 u_viewProjMat;
	Vec2 u_randomUv;
	F32 u_dt;
	F32 u_padding0;
};

const F32 noiseTexSizeX = F32(textureSize(u_noiseTex).x);

F32 genRandomFactor()
{
	const Vec2 uv = u_randomUv + Vec2(gl_GlobalInvocationID.x) / noiseTexSizeX;
	const F32 r = textureLod(u_noiseTex, u_nearestAnyRepeatSampler, uv).r;
	return saturate(r);
}

void initParticle(out GpuParticle p)
{
	const F32 randFactor = genRandomFactor();

	p.m_newWorldPosition = mix(u_props.m_minStartingPosition, u_props.m_maxStartingPosition, randFactor);
	p.m_oldWorldPosition = p.m_newWorldPosition;

	p.m_mass = mix(u_props.m_minMass, u_props.m_maxMass, randFactor);
	p.m_life = mix(u_props.m_minLife, u_props.m_maxLife, randFactor);
	p.m_acceleration = mix(u_props.m_minGravity, u_props.m_maxGravity, randFactor);

	// Calculate the initial velocity
	const Vec3 initialForce = mix(u_props.m_minForce, u_props.m_maxForce, randFactor);
	const Vec3 totalForce = (p.m_acceleration * p.m_mass) + initialForce;
	const Vec3 acceleration = totalForce / p.m_mass;
	p.m_velocity = acceleration * u_dt;
}

void main()
{
	const u32 particleIdx = gl_GlobalInvocationID.x;
	if(particleIdx >= u_particleCount)
	{
		return;
	}

	GpuParticle particle = u_particles[particleIdx];
	const F32 dt = u_dt;

	// Check if it's dead
	if(particle.m_life - dt <= 0.0)
	{
		// Dead, revive
		initParticle(particle);
	}
	else
	{
		// Simulate

		const Vec3 xp = particle.m_oldWorldPosition;
		const Vec3 xc = particle.m_acceleration * (u_dt * u_dt) + u_particles[particleIdx].m_velocity * u_dt + xp;

		// Project the point
		const Vec4 proj4 = u_viewProjMat * Vec4(xc, 1.0);
		const Vec3 proj3 = proj4.xyz / proj4.w;
		if(proj3.xy > Vec2(-1.0) && proj3.xy < Vec2(1.0))
		{
			// It's visible, test against the depth buffer

			const F32 refDepth = textureLod(u_depthMap, u_nearestAnyRepeatSampler, NDC_TO_UV(proj3.xy), 0.0).r;
			const F32 testDepth = proj3.z;

			if(testDepth >= refDepth)
			{
				// Collides, change its direction
				p.m_velocity = -p.m_velocity;
			}
		}

		particle.m_oldWorldPosition = particle.m_newWorldPosition;
		particle.m_newWorldPosition = xc;
	}

	// Write back the particle
	u_particles[particleIdx] = particle;
}

#pragma anki end