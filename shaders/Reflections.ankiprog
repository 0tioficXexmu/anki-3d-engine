<!-- 
Copyright (C) 2009-2018, Panagiotis Christopoulos Charitos and contributors.
All rights reserved.
Code licensed under the BSD License.
http://www.anki3d.org/LICENSE
-->
<shaderProgram>
	<mutators>
		<mutator name="VARIANT" values="0 1"/>
	</mutators>

	<shaders>
		<shader type="comp">
			<inputs>
				<input name="FB_SIZE" type="UVec2" const="1"/>
				<input name="WORKGROUP_SIZE" type="UVec2" const="1"/>
				<input name="MAX_STEPS" type="U32" const="1"/>
				<input name="LIGHT_BUFFER_MIP_COUNT" type="U32" const="1"/>
				<input name="HIZ_MIP_COUNT" type="U32" const="1"/>
				<input name="CLUSTER_COUNT_X" type="U32" const="1"/>
				<input name="CLUSTER_COUNT_Y" type="U32" const="1"/>
				<input name="CLUSTER_COUNT_Z" type="U32" const="1"/>
				<input name="IR_MIPMAP_COUNT" type="U32" const="1"/>
			</inputs>

			<source><![CDATA[
// if VARIANT==0 then the checkerboard pattern is (render on 'v'):
// -----
// |v| |
// | |v|
// -----


#include <shaders/Functions.glsl>
#include <shaders/Pack.glsl>
#include <shaders/glsl_cpp_common/Clusterer.h>

#define LIGHT_SET 0
#define LIGHT_SS_BINDING 0
#define LIGHT_UBO_BINDING 0
#define LIGHT_TEX_BINDING 6
#define LIGHT_INDIRECT
#define LIGHT_COMMON_UNIS
#include <shaders/ClusterLightCommon.glsl>

const IVec2 HIZ_SIZE = IVec2(FB_SIZE) >> 1;

layout(local_size_x = WORKGROUP_SIZE.x, local_size_y = WORKGROUP_SIZE.y, local_size_z = 1) in;

layout(ANKI_TEX_BINDING(0, 0)) uniform sampler2D u_gbufferRt0;
layout(ANKI_TEX_BINDING(0, 1)) uniform sampler2D u_gbufferRt1;
layout(ANKI_TEX_BINDING(0, 2)) uniform sampler2D u_gbufferRt2;
layout(ANKI_TEX_BINDING(0, 3)) uniform sampler2D u_depthRt;
layout(ANKI_TEX_BINDING(0, 4)) uniform sampler2D u_hizRt;
layout(ANKI_TEX_BINDING(0, 5)) uniform sampler2D u_lightBufferRt;

layout(ANKI_IMAGE_BINDING(0, 0)) writeonly uniform image2D out_reflAndIndirect;

// Temp buffer to hold the indirect color
shared Vec3 s_pixels[WORKGROUP_SIZE.y][WORKGROUP_SIZE.x];

#define u_normalMat Mat3(u_viewMat)

Vec4 returnSslrColor(Vec3 raySample, F32 factor, F32 roughness)
{
	// Re-project previous frame
	Vec4 v4 = u_prevViewProjMatMulInvViewProjMat * Vec4(UV_TO_NDC(raySample.xy), raySample.z, 1.0);
	raySample.xy = NDC_TO_UV(v4.xy / v4.w);
	raySample.xy = saturate(raySample.xy);

	Vec2 ndc = abs(UV_TO_NDC(raySample.xy));
	F32 contribution = max(ndc.x, ndc.y);
	contribution = 1.0 - contribution * contribution;
	contribution *= factor;

	F32 lod = F32(LIGHT_BUFFER_MIP_COUNT - 1u) * roughness;
	Vec3 color = textureLod(u_lightBufferRt, raySample.xy, lod).rgb;
	return Vec4(color, contribution);
}

// Note: All calculations in view space
Vec4 doSslr(Vec3 r, Vec3 n, Vec3 viewPos, Vec2 uv, F32 depth, F32 roughness)
{
	Vec3 p0 = viewPos;

	// Check for view facing reflections [sakibsaikia]
	Vec3 viewDir = normalize(viewPos);
	F32 cameraFacingReflectionAttenuation = 1.0 - smoothstep(0.25, 0.5, dot(-viewDir, r));
	if(cameraFacingReflectionAttenuation <= 0.0)
	{
		return Vec4(0.0);
	}

	// Compute an end point p1. This point is supposed to fall in front of the near plane. Add a small padding to near
	// to avoid having p1 touching the near plane.
	Vec3 p1 = p0 + r * (-p0.z - (u_near + 0.1));

	// Start point
	Vec3 start = Vec3(uv, depth);

	// Project end point
	Vec4 end4 = u_projMat * Vec4(p1, 1.0);
	Vec3 end = end4.xyz / end4.w;
	end.xy = NDC_TO_UV(end.xy);

	// Compute the ray and step size
	Vec3 ray = end - start;
	Vec2 texelDims = abs(ray.xy) * Vec2(HIZ_SIZE);
	F32 stepSize = length(ray.xy) / max(texelDims.x, texelDims.y);
	ray = normalize(ray);

	// Compute step
	const U32 BIG_STEP_SKIP = 32u;
	U32 stepSkip = BIG_STEP_SKIP;

	U32 l = gl_GlobalInvocationID.x & 1u;
	U32 j = gl_GlobalInvocationID.y & 1u;
	const U32 STEPS_ARR[4] = U32[](6u, 25u, 13u, 18u);
	U32 step = STEPS_ARR[l * 2u + j];
	
	// Iterate
	bool found = false;
	Vec3 raySample;
	ANKI_LOOP for(U32 iterations = 0u; iterations < MAX_STEPS; ++iterations)
	{
		raySample = start + ray * (F32(step) * stepSize);

		// Check if it's out of the view
		if(raySample.x <= 0.0 || raySample.y <= 0.0 || raySample.x >= 1.0 || raySample.y >= 1.0)
		{
			break;
		}

		F32 depth = textureLod(u_hizRt, raySample.xy, 0.0).r;

		bool hit = raySample.z - depth >= 0.0;
		if(!hit)
		{
			step += stepSkip;
		}
		else if(stepSkip > 1)
		{
			step -= BIG_STEP_SKIP - 1u;
			stepSkip = 1u;
		}
		else
		{
			found = true;
			break;
		}
	}

	//return Vec4(heatmap(F32(iterations) / F32(MAX_STEPS)), 1.0);

	if(found)
	{
		return returnSslrColor(raySample, cameraFacingReflectionAttenuation, roughness);
	}
	else
	{
		return Vec4(0.0);
	}
}

// Note: All calculations in world space
void readReflectionsAndIrradianceFromProbes(
	U32 idxOffset, Vec3 worldPos, Vec3 normal, F32 roughness, out Vec3 specIndirect, out Vec3 diffIndirect)
{
	specIndirect = Vec3(0.0);
	diffIndirect = Vec3(0.0);

	Vec3 viewDir = normalize(worldPos - u_cameraPos);
	Vec3 reflDir = reflect(viewDir, normal);

	F32 reflLod = F32(IR_MIPMAP_COUNT - 1u) * roughness;

	// Check proxy
	U32 count = u_lightIndices[idxOffset++];
	ANKI_LOOP while(count-- != 0)
	{
		ReflectionProbe probe = u_reflectionProbes[u_lightIndices[idxOffset++]];

		F32 R2 = probe.m_positionRadiusSq.w;
		Vec3 center = probe.m_positionRadiusSq.xyz;

		// Get distance from the center of the probe
		Vec3 f = worldPos - center;

		// Cubemap UV in view space
		Vec3 uv = computeCubemapVecAccurate(reflDir, R2, f);

		// Read!
		F32 cubemapIndex = probe.m_cubemapIndexPad3.x;
		Vec3 c = textureLod(u_reflectionsTex, Vec4(uv, cubemapIndex), reflLod).rgb;

		// Combine (lerp) with previous color
		F32 d = dot(f, f);
		F32 factor = d / R2;
		factor = min(factor, 1.0);
		specIndirect = mix(c, specIndirect, factor);

		// Do the same for diffuse
		uv = computeCubemapVecAccurate(normal, R2, f);
		Vec3 id = textureLod(u_irradianceTex, Vec4(uv, cubemapIndex), 0.0).rgb;
		diffIndirect = mix(id, diffIndirect, factor);
	}
}

void main()
{
	// Compute a global invocation ID that takes the checkerboard pattern into account
	IVec2 fixedInvocationId = IVec2(gl_GlobalInvocationID.xy);
	fixedInvocationId.x *= 2;
#if VARIANT == 0
	fixedInvocationId.x += ((fixedInvocationId.y + 1) & 1);
#else
	fixedInvocationId.x += ((fixedInvocationId.y + 0) & 1);
#endif

	if(fixedInvocationId.x >= I32(FB_SIZE.x) || fixedInvocationId.y >= I32(FB_SIZE.y))
	{
		// Skip threads outside the writable image
		return;
	}

	Vec2 uv = (Vec2(fixedInvocationId) + 0.5) / Vec2(FB_SIZE);
	Vec2 ndc = UV_TO_NDC(uv);

	// Read gbuffer
	GbufferInfo gbuffer;
	readGBuffer(u_gbufferRt0, u_gbufferRt1, u_gbufferRt2, uv, 0.0, gbuffer);

	// Get depth
	F32 depth = textureLod(u_depthRt, uv, 0.0).r;

	// Get world position
	Vec4 worldPos4 = u_invViewProjMat * Vec4(ndc, depth, 1.0);
	Vec3 worldPos = worldPos4.xyz / worldPos4.w;

	// Compute env BRDF
	Vec3 env;
	{
		Vec3 viewDir = normalize(u_cameraPos - worldPos);
		F32 NoV = max(EPSILON, dot(gbuffer.m_normal, viewDir));
		env = envBRDF(gbuffer.m_specular, gbuffer.m_roughness, u_integrationLut, NoV);
	}

	// Try SSR
	F32 sslrFactor = 0.0;
	Vec3 sslrCol = Vec3(0.0);
	if(env.g > 0.05)
	{
		// Get view pos
		Vec4 viewPos4 = u_invProjMat * Vec4(UV_TO_NDC(uv), depth, 1.0);
		Vec3 viewPos = viewPos4.xyz / viewPos4.w;

		// Do SSLR
		Vec3 viewDir = normalize(viewPos);
		Vec3 viewNormal = u_normalMat * gbuffer.m_normal;
		Vec3 reflVec = reflect(viewDir, viewNormal);

		Vec4 sslr = doSslr(reflVec, viewNormal, viewPos, uv, depth, gbuffer.m_roughness);
		sslrFactor = sslr.w;
		sslrCol = sslr.xyz;
		sslrCol = clamp(sslrCol, 0.0, FLT_MAX); // Fix the value just in case
	}

	// Read probes
	Vec3 probeCol = Vec3(0.0);
	Vec3 indirectCol = Vec3(0.0);
	{
		// Get first light index
		U32 clusterIdx = computeClusterIndex(u_clustererMagic, uv, worldPos, CLUSTER_COUNT_X, CLUSTER_COUNT_Y);
		U32 idxOffset = u_clusters[clusterIdx];

		// Skip decals
		U32 count = u_lightIndices[idxOffset++];
		idxOffset += count;
		
		// Skip point lights
		count = u_lightIndices[idxOffset++];
		idxOffset += count;

		// Skip spot lights
		count = u_lightIndices[idxOffset++];
		idxOffset += count;

		// Do the probe read
		readReflectionsAndIrradianceFromProbes(
			idxOffset, worldPos, gbuffer.m_normal, gbuffer.m_roughness, probeCol, indirectCol);
	}

	// Combine the SSR and probe reflections and write the result
	Vec3 finalRefl = mix(probeCol, sslrCol, sslrFactor);

	// Compute the final color
	Vec3 outColor = indirectCol * gbuffer.m_diffuse + finalRefl * env;

	// Store the color for the resolve
	s_pixels[gl_LocalInvocationID.y][gl_LocalInvocationID.x] = outColor;

	// Wait for all the threads to store their stuff
	memoryBarrierShared();
	barrier();

	// Compute the missing pixel by resolving with the right or left neighbour
	IVec2 readPixel, storePixel;
	readPixel.y = I32(gl_LocalInvocationID.y);
	storePixel.y = fixedInvocationId.y;

#if VARIANT == 0
	bool pickRightNeighbour = (fixedInvocationId.y & 1) == 1;
#else
	bool pickRightNeighbour = (fixedInvocationId.y & 1) == 0;
#endif
	I32 xOffset = (pickRightNeighbour) ? 1 : -1;
	
	readPixel.x = I32(gl_LocalInvocationID.x) + xOffset;
	readPixel.x = clamp(readPixel.x, 0, I32(WORKGROUP_SIZE.x - 1));

	storePixel.x = fixedInvocationId.x + xOffset;

	Vec3 missingColor = (outColor + s_pixels[readPixel.y][readPixel.x]) * 0.5; // average

	// Store both the pixels
	imageStore(out_reflAndIndirect, fixedInvocationId, Vec4(outColor, 0.0));
	imageStore(out_reflAndIndirect, storePixel, Vec4(missingColor, 0.0));
}
			]]></source>
		</shader>
	</shaders>
</shaderProgram>
