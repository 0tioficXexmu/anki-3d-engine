// Copyright (C) 2009-2019, Panagiotis Christopoulos Charitos and contributors.
// All rights reserved.
// Code licensed under the BSD License.
// http://www.anki3d.org/LICENSE

// This shader does a particle simulation

#pragma anki input const U32 WORKGROUP_SIZE_X

#pragma anki start comp

#include <shaders/glsl_cpp_common/GpuParticles.h>
#include <shaders/Common.glsl>

layout(local_size_x = WORKGROUP_SIZE_X, local_size_y = 1, local_size_z = 1) in;

layout(set = 0, binding = 0) uniform texture2D u_depthMap;

layout(set = 1, binding = 0) buffer ssbo_
{
	GpuParticle u_particles[];
};

layout(set = 1, binding = 1) buffer ubo_
{
	GpuParticleEmitterProperties u_props;
};

layout(set = 1, binding = 2) readonly buffer ubo1_
{
	U32 u_randomFactorCount;
	F32 u_randomFactors[];
};

layout(std430, push_constant, row_major) pc_
{
	GpuParticleSimulationState u_regs;
};

F32 readDepth(Vec2 uv)
{
	const Vec2 texSize = Vec2(textureSize(u_depthMap));
	IVec2 textureSpaceUv = IVec2(uv * texSize);
	textureSpaceUv = clamp(textureSpaceUv, IVec2(0), texSize - 1);
	return texelFetch(u_depthMap, textureSpaceUv, 0).r;
}

void initParticle(out GpuParticle p)
{
	const F32 randFactor = u_randomFactors[(gl_GlobalInvocationID.x + u_regs.m_randomIndex) % u_randomFactorCount];

	p.m_newWorldPosition =
		mix(u_props.m_minStartingPosition, u_props.m_maxStartingPosition, randFactor) + u_regs.m_emitterPosition;
	p.m_oldWorldPosition = p.m_newWorldPosition;

	p.m_mass = mix(u_props.m_minMass, u_props.m_maxMass, randFactor);
	p.m_life = mix(u_props.m_minLife, u_props.m_maxLife, randFactor);
	p.m_acceleration = mix(u_props.m_minGravity, u_props.m_maxGravity, randFactor);

	// Calculate the initial velocity
	const Vec3 initialForce = mix(u_props.m_minForce, u_props.m_maxForce, randFactor);
	const Vec3 totalForce = (p.m_acceleration * p.m_mass) + initialForce;
	const Vec3 acceleration = totalForce / p.m_mass;
	p.m_velocity = acceleration * u_regs.m_dt;
}

void main()
{
	const u32 particleIdx = gl_GlobalInvocationID.x;
	if(particleIdx >= u_props.m_particleCount)
	{
		return;
	}

	GpuParticle particle = u_particles[particleIdx];
	const F32 dt = u_regs.m_dt;

	// Check if it's dead
	if(particle.m_life - dt <= 0.0)
	{
		// Dead, revive
		initParticle(particle);
	}
	else
	{
		// Simulate

		const Vec3 xp = particle.m_oldWorldPosition;
		const Vec3 xc = particle.m_acceleration * (dt * dt) + u_particles[particleIdx].m_velocity * dt + xp;

		// Project the point
		const Vec4 proj4 = u_regs.m_viewProjMat * Vec4(xc, 1.0);
		const Vec3 proj3 = proj4.xyz / proj4.w;
		if(proj3.xy > Vec2(-1.0) && proj3.xy < Vec2(1.0))
		{
			// It's visible, test against the depth buffer

			const F32 refDepth = readDepth(NDC_TO_UV(proj3.xy));
			const F32 testDepth = proj3.z;

			if(testDepth >= refDepth)
			{
				// Collides, change its direction
				p.m_velocity = -p.m_velocity;
			}
		}

		particle.m_oldWorldPosition = particle.m_newWorldPosition;
		particle.m_newWorldPosition = xc;
	}

	// Write back the particle
	u_particles[particleIdx] = particle;
}

#pragma anki end