// Copyright (C) 2009-2018, Panagiotis Christopoulos Charitos and contributors.
// All rights reserved.
// Code licensed under the BSD License.
// http://www.anki3d.org/LICENSE

// This shader accumulates the lighting for every cluster fraction

#pragma anki mutator ENABLE_SHADOWS 0 1

#pragma anki input const UVec3 VOLUME_SIZE
#pragma anki input const UVec3 CLUSTER_COUNT
#pragma anki input const U32 FINAL_CLUSTER_Z
#pragma anki input const UVec3 FRACTION
#pragma anki input const UVec3 WORKGROUP_SIZE
#pragma anki input const UVec3 NOISE_TEX_SIZE

#pragma anki start comp

// Lower the ESM constant to smooth the shadows
#define ESM_CONSTANT 20.0

layout(local_size_x = WORKGROUP_SIZE.x, local_size_y = WORKGROUP_SIZE.y, local_size_z = WORKGROUP_SIZE.z) in;

layout(ANKI_IMAGE_BINDING(0, 0)) writeonly uniform image3D u_volume;
layout(ANKI_TEX_BINDING(0, 0)) uniform sampler3D u_noiseTex;
layout(ANKI_TEX_BINDING(0, 1)) uniform sampler3D u_prevVolume;

struct PushConsts
{
	Vec4 m_noiseOffsetPad3;
};
ANKI_PUSH_CONSTANTS(PushConsts, u_regs);

#define u_noiseOffset u_regs.m_noiseOffsetPad3.x

#define LIGHT_TEX_BINDING 2
#define LIGHT_UBO_BINDING 0
#define LIGHT_SS_BINDING 0
#define LIGHT_SET 0
#define LIGHT_LIGHTS
#define LIGHT_COMMON_UNIS
#include <shaders/ClusteredShadingCommon.glsl>

Vec3 g_globalInvocationID = Vec3(gl_GlobalInvocationID);

Vec3 readRand()
{
	Vec3 uv = (g_globalInvocationID + 0.5) / Vec3(NOISE_TEX_SIZE);
	uv.z += u_noiseOffset;
	return textureLod(u_noiseTex, uv, 0.0).rgb;
}

Vec3 worldPosInsideCluster(Vec3 relativePos)
{
	// Compute the cluster Z as float
	F32 clusterKNear = g_globalInvocationID.z * (F32(FINAL_CLUSTER_Z + 1u) / F32(VOLUME_SIZE.z));
	F32 clusterKFar = (g_globalInvocationID.z + 1.0) * (F32(FINAL_CLUSTER_Z + 1u) / F32(VOLUME_SIZE.z));
	F32 clusterK = mix(clusterKNear, clusterKFar, relativePos.z);

	// Get a Z value
	F32 zVSpace = -computeClusterNearf(u_clustererMagic, clusterK);

	// Get a XY value
	Vec2 uvMin = g_globalInvocationID.xy / Vec2(VOLUME_SIZE.xy);
	Vec2 uvMax = uvMin + 1.0 / Vec2(VOLUME_SIZE.xy);
	Vec2 uv = mix(uvMin, uvMax, relativePos.xy);
	Vec2 ndc = UV_TO_NDC(uv);
	Vec2 xyZVspace = ndc * u_unprojectionParams.xy * zVSpace;

	// Get the pos
	Vec4 worldPos4 = u_invViewMat * Vec4(xyZVspace, zVSpace, 1.0);
	Vec3 worldPos = worldPos4.xyz;

	return worldPos;
}

Vec3 accumulateLights(U32 clusterIdx, Vec3 worldPos)
{
	Vec3 color = Vec3(0.0);

	// Get ID offset
	U32 idxOffset = u_clusters[clusterIdx];

	// Skip decals
	U32 count = u_lightIndices[idxOffset];
	idxOffset += count + 1u;

	// Point lights
	count = u_lightIndices[idxOffset++];
	U32 idxOffsetEnd = idxOffset + count;
	ANKI_LOOP while(idxOffset < idxOffsetEnd)
	{
		PointLight light = u_pointLights[u_lightIndices[idxOffset++]];

		Vec3 frag2Light = light.m_posRadius.xyz - worldPos;
		F32 factor = computeAttenuationFactor(light.m_posRadius.w, frag2Light);

#if ENABLE_SHADOWS
		if(light.m_diffuseColorTileSize.w >= 0.0)
		{
			factor *= computeShadowFactorOmni(
				frag2Light, light.m_radiusPad1.x, light.m_atlasTiles, light.m_diffuseColorTileSize.w, u_shadowTex);
		}
#endif

		color += light.m_diffuseColorTileSize.rgb * factor;
	}

	// Spot lights
	count = u_lightIndices[idxOffset++];
	idxOffsetEnd = idxOffset + count;
	ANKI_LOOP while(idxOffset < idxOffsetEnd)
	{
		SpotLight light = u_spotLights[u_lightIndices[idxOffset++]];

		Vec3 frag2Light = light.m_posRadius.xyz - worldPos;
		F32 factor = computeAttenuationFactor(light.m_posRadius.w, frag2Light);

		Vec3 l = normalize(frag2Light);

		factor *=
			computeSpotFactor(l, light.m_outerCosInnerCos.x, light.m_outerCosInnerCos.y, light.m_lightDirRadius.xyz);

#if ENABLE_SHADOWS
		F32 shadowmapLayerIdx = light.m_diffuseColorShadowmapId.w;
		if(shadowmapLayerIdx >= 0.0)
		{
			factor *=
				computeShadowFactorSpot(light.m_texProjectionMat, worldPos, light.m_lightDirRadius.w, u_shadowTex);
		}
#endif

		color += light.m_diffuseColorShadowmapId.rgb * factor;
	}

	return color;
}

void main()
{
	if(any(greaterThanEqual(gl_GlobalInvocationID.xyz, VOLUME_SIZE)))
	{
		return;
	}

	// Find the cluster
	UVec3 clusterXYZ = gl_GlobalInvocationID / FRACTION;
	U32 clusterIdx = clusterXYZ.z * (CLUSTER_COUNT.x * CLUSTER_COUNT.y) + clusterXYZ.y * CLUSTER_COUNT.x + clusterXYZ.x;

	// Find a random pos inside the cluster
	Vec3 worldPos = worldPosInsideCluster(readRand());

	// Get lighting
	Vec3 color = accumulateLights(clusterIdx, worldPos);

	// Read the prev result
	{
		// Better get a new world pos in the center of the cluster. Using worldPos creates noisy results
		Vec3 midWPos = worldPosInsideCluster(Vec3(0.5));

		// Compute UV
		Vec4 prevClipPos4 = u_prevViewProjMat * Vec4(midWPos, 1.0);
		Vec2 prevUv = NDC_TO_UV(prevClipPos4.xy / prevClipPos4.w);

		// Compute new Z tex coord
		F32 k = computeClusterKf(u_prevClustererMagic, midWPos);
		k /= F32(FINAL_CLUSTER_Z + 1u);

		// Read prev
		Vec3 prev = textureLod(u_prevVolume, Vec3(prevUv, k), 0.0).rgb;

		// Modulate
		color = mix(prev, color, 1.0 / 16.0);
	}

	// Write result
	imageStore(u_volume, IVec3(gl_GlobalInvocationID), Vec4(color, 0.0));
}

#pragma anki end