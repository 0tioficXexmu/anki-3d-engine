// Copyright (C) 2009-2018, Panagiotis Christopoulos Charitos and contributors.
// All rights reserved.
// Code licensed under the BSD License.
// http://www.anki3d.org/LICENSE

#pragma anki input const UVec2 WORKGROUP_SIZE
#pragma anki input const UVec2 FB_SIZE
#pragma anki input const U32 MAX_SAMPLES

#pragma anki start comp
#include <shaders/Functions.glsl>

layout(local_size_x = WORKGROUP_SIZE.x, local_size_y = WORKGROUP_SIZE.y, local_size_z = 1) in;

layout(ANKI_TEX_BINDING(0, 0)) uniform sampler2D u_velocityRt;
layout(ANKI_TEX_BINDING(0, 1)) uniform sampler2D u_toBlurRt;

layout(ANKI_IMAGE_BINDING(0, 0)) writeonly uniform image2D out_img;

const Vec2 TEXEL_SIZE = 1.0 / Vec2(FB_SIZE);

void main()
{
	SKIP_OUT_OF_BOUNDS_INVOCATIONS();

	// Crnt UV
	Vec2 nowUv = (Vec2(gl_GlobalInvocationID.xy) + 0.5) / Vec2(FB_SIZE);

	// UV this frag had previously
	Vec2 pastUv = textureLod(u_velocityRt, nowUv, 0.0).rg;

	// Do the work
	Vec3 outColor;
	ANKI_BRANCH if(pastUv.x >= 0.0)
	{
		// Dynamic object

		// March direction
		Vec2 dir = pastUv - nowUv;

		Vec2 slopes = abs(dir);

		Vec2 sampleCount2D = slopes * Vec2(FB_SIZE);
		F32 sampleCountf = max(sampleCount2D.x, sampleCount2D.y);
		sampleCountf = clamp(sampleCountf, 1.0, F32(MAX_SAMPLES));
		sampleCountf = round(sampleCountf);

		outColor = Vec3(0.0);
		ANKI_LOOP for(F32 s = 0.0; s < sampleCountf; s += 1.0)
		{
			F32 f = s / sampleCountf;
			Vec2 sampleUv = nowUv + dir * f;

			outColor += textureLod(u_toBlurRt, sampleUv, 0.0).rgb;
		}

		outColor /= sampleCountf;
	}
	else
	{
		// Static object, ATM camera motion blur is not supported

		outColor = textureLod(u_toBlurRt, nowUv, 0.0).rgb;
	}

	imageStore(out_img, IVec2(gl_GlobalInvocationID.xy), Vec4(outColor, 0.0));
}

#pragma anki end