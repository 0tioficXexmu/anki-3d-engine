// Copyright (C) 2009-2019, Panagiotis Christopoulos Charitos and contributors.
// All rights reserved.
// Code licensed under the BSD License.
// http://www.anki3d.org/LICENSE

// Compute the irradiance given a light shading result. The irradiance will be stored in an ambient dice.

#pragma anki input const U32 INPUT_TEXTURES_HEIGHT

#pragma anki start comp

#include <shaders/Functions.glsl>
#include <shaders/Pack.glsl>
#include <shaders/LightFunctions.glsl>

#define DEBUG_MODE 0 // 0: disable, 1: different color per dice face, 2: different color per cell
#define SECOND_BOUNCE 1

layout(local_size_x = INPUT_TEXTURES_HEIGHT, local_size_y = INPUT_TEXTURES_HEIGHT, local_size_z = 1) in;

layout(set = 0, binding = 0) uniform sampler u_nearestAnyClampSampler;
layout(set = 0, binding = 1) uniform texture2D u_lightShadingTex;
layout(set = 0, binding = 2) uniform texture2D u_gbufferTex0;
layout(set = 0, binding = 3) uniform texture2D u_gbufferTex1;
layout(set = 0, binding = 4) uniform texture2D u_gbufferTex2;
layout(set = 0, binding = 5) uniform writeonly image3D u_irradianceVolumes[6u];

// This is a temporary buffer used instead of shared memory because it's too large
layout(set = 0, binding = 6, std430) buffer ssbo_
{
	Vec4 u_integrationResults[6u][INPUT_TEXTURES_HEIGHT * INPUT_TEXTURES_HEIGHT];
};

layout(push_constant, std430) uniform pc_
{
	IVec3 u_volumeTexel;
	I32 u_padding;
};

shared Vec3 s_diceIrradiance[6u];

void main()
{
	const F32 INPUT_TEXTURES_HEIGHT_F = F32(INPUT_TEXTURES_HEIGHT);
	const Vec2 INPUT_TEXTURES_SIZE = Vec2(INPUT_TEXTURES_HEIGHT * 6u, INPUT_TEXTURES_HEIGHT);

	// Compute the NDC used in cubeCoordSolidAngle
	const Vec2 faceUv = (Vec2(gl_LocalInvocationID.xy) + 0.5) / INPUT_TEXTURES_HEIGHT_F;
	const Vec2 ndc = UV_TO_NDC(faceUv);

	// Initialize
	ANKI_UNROLL for(U32 f = 0u; f < 6u; ++f)
	{
		const Vec2 uv = (Vec2(gl_LocalInvocationID.x + INPUT_TEXTURES_HEIGHT_F * f, gl_LocalInvocationID.y) + 0.5)
						/ INPUT_TEXTURES_SIZE;

		// Get the direction of the dice face
		const Vec3 diceDir = getCubemapDirection(Vec2(0.0), f);

		const Vec3 r = getCubemapDirection(ndc, f);

		// Compute integral part
		const F32 lambert = max(0.0, dot(r, diceDir));
		const Vec3 lightShading = textureLod(u_lightShadingTex, u_nearestAnyClampSampler, uv, 0.0).rgb;
		const Vec3 irradiance = lightShading * lambert * cubeCoordSolidAngle(ndc, INPUT_TEXTURES_HEIGHT_F);

		// Store
		u_integrationResults[f][gl_LocalInvocationID.y * INPUT_TEXTURES_HEIGHT + gl_LocalInvocationID.x] =
			irradiance.xyzx;
	}

	memoryBarrierBuffer();
	barrier();

	// Reduce using prefix sum
	const U32 WG_SIZE = INPUT_TEXTURES_HEIGHT * INPUT_TEXTURES_HEIGHT;
	ANKI_LOOP for(U32 s = WG_SIZE / 2u; s > 0u; s >>= 1u)
	{
		if(gl_LocalInvocationIndex < s)
		{
			ANKI_UNROLL for(U32 f = 0u; f < 6u; ++f)
			{
				u_integrationResults[f][gl_LocalInvocationIndex] +=
					u_integrationResults[f][gl_LocalInvocationIndex + s];
			}
		}

		memoryBarrierBuffer();
		barrier();
	}

	if(gl_LocalInvocationIndex < 6u)
	{
		s_diceIrradiance[gl_LocalInvocationIndex] = u_integrationResults[gl_LocalInvocationIndex][0].xyz;
	}

	memoryBarrierShared();
	barrier();

#if SECOND_BOUNCE == 1
	// Initialize again for the 2nd bounce
	ANKI_UNROLL for(U32 f = 0u; f < 6u; ++f)
	{
		const Vec2 uv = (Vec2(gl_LocalInvocationID.x + INPUT_TEXTURES_HEIGHT_F * f, gl_LocalInvocationID.y) + 0.5)
						/ INPUT_TEXTURES_SIZE;

		// Get the direction of the dice face
		const Vec3 diceDir = getCubemapDirection(Vec2(0.0), f);

		const Vec3 r = getCubemapDirection(ndc, f);

		// Compute integral part
		const F32 lambert = max(0.0, dot(r, diceDir));

		// Read the gbuffer
		GbufferInfo gbuffer;
		readGBuffer(u_gbufferTex0, u_gbufferTex1, u_gbufferTex2, u_nearestAnyClampSampler, uv, 0.0, gbuffer);

		// Sample irradiance
		Vec3 firstBounceIrradiance = sampleAmbientDice(s_diceIrradiance[0],
			s_diceIrradiance[1],
			s_diceIrradiance[2],
			s_diceIrradiance[3],
			s_diceIrradiance[4],
			s_diceIrradiance[5],
			gbuffer.m_normal);
		firstBounceIrradiance = gbuffer.m_diffuse * firstBounceIrradiance / PI;

		// Compute 2nd bounce
		const Vec3 lightShading = textureLod(u_lightShadingTex, u_nearestAnyClampSampler, uv, 0.0).rgb;
		const Vec3 irradiance =
			(firstBounceIrradiance + lightShading * lambert) * cubeCoordSolidAngle(ndc, INPUT_TEXTURES_HEIGHT_F);

		// Store
		u_integrationResults[f][gl_LocalInvocationID.y * INPUT_TEXTURES_HEIGHT + gl_LocalInvocationID.x] =
			irradiance.xyzx;
	}

	memoryBarrierBuffer();
	barrier();

	// Reduce using prefix sum again
	ANKI_LOOP for(U32 s = WG_SIZE / 2u; s > 0u; s >>= 1u)
	{
		if(gl_LocalInvocationIndex < s)
		{
			ANKI_UNROLL for(U32 f = 0u; f < 6u; ++f)
			{
				u_integrationResults[f][gl_LocalInvocationIndex] +=
					u_integrationResults[f][gl_LocalInvocationIndex + s];
			}
		}

		memoryBarrierBuffer();
		barrier();
	}
#endif

	// Store the results
	ANKI_BRANCH if(gl_LocalInvocationIndex == 0u)
	{
		ANKI_UNROLL for(U32 f = 0u; f < 6u; ++f)
		{
#if DEBUG_MODE == 0
#	if SECOND_BOUNCE == 1
			Vec3 irradiance = u_integrationResults[f][0].xyz;
#	else
			Vec3 irradiance = s_diceIrradiance[f];
#	endif
			irradiance /= PI; // Pre-divide
			const Vec3 toStoreValue = irradiance;
#elif DEBUG_MODE == 1
			const Vec3 toStoreValue = colorPerCubeFace(f);
#else
			const UVec3 volumeSize = UVec3(imageSize(u_irradianceVolumes[0]));
			const U32 cellIdx =
				u_volumeTexel.z * volumeSize.x * volumeSize.y + u_volumeTexel.y * volumeSize.x + u_volumeTexel.x;
			const F32 headmapFactor = F32(cellIdx) / F32(volumeSize.x * volumeSize.y * volumeSize.z);
			const Vec3 toStoreValue = heatmap(headmapFactor);
#endif

			imageStore(u_irradianceVolumes[f], u_volumeTexel, Vec4(toStoreValue, 0.0));
		}
	}
}

#pragma anki end
