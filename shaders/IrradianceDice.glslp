// Copyright (C) 2009-2019, Panagiotis Christopoulos Charitos and contributors.
// All rights reserved.
// Code licensed under the BSD License.
// http://www.anki3d.org/LICENSE

// Compute the irradiance given a light shading result. The irradiance will be stored in an ambient dice.

#pragma anki input const U32 INPUT_TEXTURES_HEIGHT

#pragma anki start comp

#include <shaders/Functions.glsl>
#include <shaders/Pack.glsl>
#include <shaders/LightFunctions.glsl>

layout(local_size_x = 6, local_size_y = 1, local_size_z = 1) in;

layout(set = 0, binding = 0) uniform sampler u_nearestAnyClampSampler;
layout(set = 0, binding = 1) uniform texture2D u_lightShadingTex;
layout(set = 0, binding = 2) uniform texture2D u_gbufferTex0;
layout(set = 0, binding = 3) uniform texture2D u_gbufferTex1;
layout(set = 0, binding = 4) uniform texture2D u_gbufferTex2;
layout(set = 0, binding = 5) uniform writeonly image3D u_irradianceVolumes[6];

layout(push_constant, std430) uniform pc_
{
	IVec3 u_volumeTexel;
	I32 u_padding;
};

shared Vec3 s_diceColors[6];

void main()
{
	const F32 INPUT_TEXTURES_HEIGHT_F = F32(INPUT_TEXTURES_HEIGHT);
	const U32 diceFace = gl_LocalInvocationID.x;

	// Get the r coordinate of the current direction of the dice
	const Vec3 ri = getCubemapDirection(Vec2(0.0), diceFace);

	// For all the faces and texels of the environment map integrate to compute the irradiance for a face
	Vec3 irradiance = Vec3(0.0);
	ANKI_LOOP for(U32 f = 0u; f < 6u; ++f)
	{
		ANKI_LOOP for(U32 i = 0u; i < INPUT_TEXTURES_HEIGHT; ++i)
		{
			ANKI_LOOP for(U32 j = 0u; j < INPUT_TEXTURES_HEIGHT; ++j)
			{
				const Vec2 uv = Vec2(j + f * INPUT_TEXTURES_HEIGHT_F, i)
								/ Vec2(6.0 * INPUT_TEXTURES_HEIGHT_F, INPUT_TEXTURES_HEIGHT_F);
				const Vec2 ndc = UV_TO_NDC(uv);

				const Vec3 r = getCubemapDirection(ndc, f);
				const F32 lambert = dot(r, ri);

				if(lambert > 0.0)
				{
					const Vec3 lightShading = textureLod(u_lightShadingTex, u_nearestAnyClampSampler, uv, 0.0).rgb;
					irradiance += lightShading * lambert * cubeCoordSolidAngle(ndc, INPUT_TEXTURES_HEIGHT_F);
				}
			}
		}
	}

	s_diceColors[diceFace] = irradiance;
	memoryBarrierShared();
	barrier();

	// 2nd bounce
	irradiance = Vec3(0.0);
	ANKI_LOOP for(U32 f = 0u; f < 6u; ++f)
	{
		ANKI_LOOP for(U32 i = 0u; i < INPUT_TEXTURES_HEIGHT; ++i)
		{
			ANKI_LOOP for(U32 j = 0u; j < INPUT_TEXTURES_HEIGHT; ++j)
			{
				const Vec2 uv = Vec2(j + f * INPUT_TEXTURES_HEIGHT_F, i)
								/ Vec2(6.0 * INPUT_TEXTURES_HEIGHT_F, INPUT_TEXTURES_HEIGHT_F);
				const Vec2 ndc = UV_TO_NDC(uv);

				const Vec3 r = getCubemapDirection(ndc, f);
				const F32 lambert = dot(r, ri);

				if(lambert > 0.0)
				{
					// Read the gbuffer
					GbufferInfo gbuffer;
					readGBuffer(
						u_gbufferTex0, u_gbufferTex1, u_gbufferTex2, u_nearestAnyClampSampler, uv, 0.0, gbuffer);

					// Sample irradiance
					Vec3 firstBounceIrradiance = sampleAmbientDice(s_diceColors[0],
						s_diceColors[1],
						s_diceColors[2],
						s_diceColors[3],
						s_diceColors[4],
						s_diceColors[5],
						gbuffer.m_normal);
					firstBounceIrradiance = gbuffer.m_diffuse * firstBounceIrradiance / PI;

					// Compute 2nd bounce
					const Vec3 lightShading = textureLod(u_lightShadingTex, u_nearestAnyClampSampler, uv, 0.0).rgb;
					irradiance += firstBounceIrradiance
								  + lightShading * lambert * cubeCoordSolidAngle(ndc, INPUT_TEXTURES_HEIGHT_F);
				}
			}
		}
	}

	// Pre-divide
	irradiance *= (1.0 / PI);

	// Store the result
	imageStore(u_irradianceVolumes[nonuniformEXT(diceFace)], u_volumeTexel, Vec4(irradiance, 0.0));
}

#pragma anki end