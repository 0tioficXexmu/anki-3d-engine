// Copyright (C) 2009-2020, Panagiotis Christopoulos Charitos and contributors.
// All rights reserved.
// Code licensed under the BSD License.
// http://www.anki3d.org/LICENSE

#pragma anki library RtShadows
#pragma anki sub_library Main

#pragma anki mutator ALPHA_TEXTURE 0 1

#include <shaders/Common.glsl>
#include <shaders/glsl_cpp_common/Model.h>

struct Payload
{
	F32 m_shadowFactor;
};

#if ALPHA_TEXTURE == 1
layout(set = 0, binding = 0, scalar) buffer b_ankiModelInstances
{
	ModelInstance u_ankiModelInstances[];
};

layout(set = 0, binding = 1) uniform texture2D u_diffTex;
layout(set = 0, binding = 2) uniform sampler u_ankiGlobalSampler;

ANKI_BINDLESS_SET(1);
#endif

#pragma anki start ahit

layout(location = 0) rayPayloadInEXT Payload p_payload;

hitAttributeEXT vec2 g_attribs;

ANKI_REF(U16Vec3, 2);
ANKI_REF(Vertex, 4);

void main()
{
#if ALPHA_TEXTURE == 1
	const Mesh mesh = u_ankiModelInstances[nonuniformEXT(gl_InstanceID)].m_mesh;

	const U32 offset = gl_PrimitiveID * ANKI_SIZEOF(U16Vec3);
	const U16Vec3 indices = U16Vec3Ref(nonuniformEXT(mesh.m_indexBufferPtr + offset)).m_value;

	const Vertex vert0 = VertexRef(mesh.m_vertexBufferPtr + indices[0] * SIZEOF_VERTEX).m_value;
	const Vertex vert1 = VertexRef(mesh.m_vertexBufferPtr + indices[1] * SIZEOF_VERTEX).m_value;
	const Vertex vert2 = VertexRef(mesh.m_vertexBufferPtr + indices[2] * SIZEOF_VERTEX).m_value;

	const Vec3 barycentrics = Vec3(1.0f - g_attribs.x - g_attribs.y, g_attribs.x, g_attribs.y);

	const Vec2 uv = vert0.m_uvs[0] * barycentrics.x + vert1.m_uvs[0] * barycentrics.y + vert2.m_uvs[0] * barycentrics.z;

	const F32 alpha = textureLod(u_diffTex, u_ankiGlobalSampler, uv, 2).a;

	p_payload.m_shadowFactor += alpha;

	if(p_payload.m_shadowFactor >= 1.0)
	{
		terminateRayEXT();
	}
#else
	p_payload.m_shadowFactor = 1.0;
	terminateRayEXT();
#endif
}
#pragma anki end
