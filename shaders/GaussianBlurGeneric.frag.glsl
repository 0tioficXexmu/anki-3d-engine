// Copyright (C) 2009-2016, Panagiotis Christopoulos Charitos.
// All rights reserved.
// Code licensed under the BSD License.
// http://www.anki3d.org/LICENSE

// Weights and offsets generated by GaussialBlur.h from Intel
//
// Switches: VPASS or HPASS, COL_RGBA or COL_RGB or COL_R
// Also must define TEXTURE_SIZE and KERNEL_SIZE

#include "shaders/Common.glsl"

// Preprocessor switches sanity checks
#if !defined(VPASS) && !defined(HPASS)
#error See file
#endif

#if !(defined(COL_RGBA) || defined(COL_RGB) || defined(COL_R))
#error See file
#endif

#if !defined(TEXTURE_SIZE)
#error See file
#endif

layout(TEX_BINDING(0, 0)) uniform sampler2D u_tex; ///< Input FAI

layout(location = 0) in vec2 in_uv;

// Determine color type
#if defined(COL_RGBA)
#define COL_TYPE vec4
#elif defined(COL_RGB)
#define COL_TYPE vec3
#elif defined(COL_R)
#define COL_TYPE float
#endif

// Determine tex fetch
#if defined(COL_RGBA)
#define TEX_FETCH rgba
#elif defined(COL_RGB)
#define TEX_FETCH rgb
#elif defined(COL_R)
#define TEX_FETCH r
#endif

// Output
layout(location = 0) out COL_TYPE out_color;

#if KERNEL_SIZE == 3
const uint STEP_COUNT = 1u;
const float WEIGHTS[STEP_COUNT] = {0.50000};
const float OFFSETS[STEP_COUNT] = {0.01742};
#elif KERNEL_SIZE == 7
const uint STEP_COUNT = 2u;
const float WEIGHTS[STEP_COUNT] = {0.44908, 0.05092};
const float OFFSETS[STEP_COUNT] = {0.53805, 2.06278};
#elif KERNEL_SIZE == 11
const uint STEP_COUNT = 3u;
const float WEIGHTS[STEP_COUNT] = {0.33023, 0.15701, 0.01276};
const float OFFSETS[STEP_COUNT] = {0.62184, 2.27310, 4.14653};
#elif KERNEL_SIZE == 15
const uint STEP_COUNT = 4u;
const float WEIGHTS[STEP_COUNT] = {0.24961, 0.19246, 0.05148, 0.00645};
const float OFFSETS[STEP_COUNT] = {0.64434, 2.37885, 4.29111, 6.21661};
#elif KERNEL_SIZE == 19
const uint STEP_COUNT = 5u;
const float WEIGHTS[STEP_COUNT] = {0.19955, 0.18945, 0.08376, 0.02321, 0.00403};
const float OFFSETS[STEP_COUNT] = {0.65319, 2.42547, 4.36803, 6.31412, 8.26479};
#else
#error See file
#endif

void main()
{
#if defined(VPASS)
	const vec2 TEXEL_SIZE = vec2(0.0, 1.0 / TEXTURE_SIZE.y);
#else
	const vec2 TEXEL_SIZE = vec2(1.0 / TEXTURE_SIZE.x, 0.0);
#endif

	out_color = COL_TYPE(0.0);
	for(uint i = 0; i < STEP_COUNT; ++i)
	{
		vec2 texCoordOffset = OFFSETS[i] * TEXEL_SIZE;
		COL_TYPE col = texture(u_tex, in_uv + texCoordOffset).TEX_FETCH
			+ texture(u_tex, in_uv - texCoordOffset).TEX_FETCH;
		out_color += WEIGHTS[i] * col;
	}
}
