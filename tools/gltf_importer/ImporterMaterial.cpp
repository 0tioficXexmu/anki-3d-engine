// Copyright (C) 2009-2019, Panagiotis Christopoulos Charitos and contributors.
// All rights reserved.
// Code licensed under the BSD License.
// http://www.anki3d.org/LICENSE

#include "Importer.h"

#define STB_IMAGE_IMPLEMENTATION
#define STBI_ASSERT(x) ANKI_ASSERT(x)
#include <stb/stb_image.h>

namespace anki
{

const char* MATERIAL_TEMPLATE = R"(<!-- This file is auto generated by ImporterMaterial.cpp -->
<material shaderProgram="shaders/GBufferGeneric.glslp">
	<mutators>
		<mutator name="DIFFUSE_TEX" value="%diffTexMutator%"/>
		<mutator name="SPECULAR_TEX" value="%specTexMutator%"/>
		<mutator name="ROUGHNESS_TEX" value="%roughnessTexMutator%"/>
		<mutator name="METAL_TEX" value="%metalTexMutator%"/>
		<mutator name="NORMAL_TEX" value="%normalTexMutator%"/>
		<mutator name="PARALLAX" value="%parallaxMutator%"/>
		<mutator name="EMISSIVE_TEX" value="%emissiveTexMutator%"/>
	</mutators>

	<inputs>
		<input shaderInput="mvp" builtin="MODEL_VIEW_PROJECTION_MATRIX"/>
		<input shaderInput="prevMvp" builtin="PREVIOUS_MODEL_VIEW_PROJECTION_MATRIX"/>
		<input shaderInput="rotationMat" builtin="ROTATION_MATRIX"/>
		<input shaderInput="globalSampler" builtin="GLOBAL_SAMPLER"/>
		%parallaxInput%

		%diff%
		%spec%
		%roughness%
		%metallic%
		%normal%
		%emission%
		%subsurface%
		%height%
	</inputs>
</material>
)";

static std::string replaceAllString(const std::string& str, const std::string& from, const std::string& to)
{
	if(from.empty())
	{
		return str;
	}

	std::string out = str;
	size_t start_pos = 0;
	while((start_pos = out.find(from, start_pos)) != std::string::npos)
	{
		out.replace(start_pos, from.length(), to);
		start_pos += to.length();
	}

	return out;
}

static CString getTextureUri(const cgltf_texture_view& view)
{
	ANKI_ASSERT(view.texture);
	ANKI_ASSERT(view.texture->image);
	ANKI_ASSERT(view.texture->image->uri);
	return view.texture->image->uri;
}

/// Read the texture and find out if
static Error identifyMetallicRoughnessTexture(CString fname, F32& constantMetalines, F32& constantRoughness)
{
	int width, height, comp;
	U8Vec4* data = reinterpret_cast<U8Vec4*>(stbi_load(fname.cstr(), &width, &height, &comp, 4));
	if(!data)
	{
		ANKI_GLTF_LOGE("Failed to read: %s", fname.cstr());
		return Error::FUNCTION_FAILED;
	}

	const F32 epsilon = 1.0f / 255.0f;
	for(int y = 0; y < height; ++y)
	{
		for(int x = 0; x < width; ++x)
		{
			const U8Vec4& pixel = *(data + y * width + x);
			const F32 m = F32(pixel.z()) / 255.0f;
			const F32 r = F32(pixel.y()) / 255.0f;

			if(x == 0 && y == 0)
			{
				// Initialize
				constantMetalines = m;
				constantRoughness = r;
			}
			else
			{
				if(constantMetalines < 0.0f || absolute(m - constantMetalines) > epsilon)
				{
					constantMetalines = -1.0f;
				}

				if(constantRoughness < 0.0f || absolute(r - constantRoughness) > epsilon)
				{
					constantRoughness = -1.0f;
				}
			}
		}
	}

	stbi_image_free(data);

	return Error::NONE;
}

Error Importer::writeMaterial(const cgltf_material& mtl)
{
	StringAuto fname(m_alloc);
	fname.sprintf("%s%s.ankimtl", m_outDir.cstr(), mtl.name);
	ANKI_GLTF_LOGI("Importing material %s", fname.cstr());

	if(!mtl.has_pbr_metallic_roughness)
	{
		ANKI_GLTF_LOGE("Expecting PBR metallic roughness");
		return Error::USER_DATA;
	}

	HashMapAuto<CString, StringAuto> extras(m_alloc);
	ANKI_CHECK(getExtras(mtl.extras, extras));

	std::string xml = XML_HEADER + std::string("\n") + MATERIAL_TEMPLATE;

	// Diffuse
	if(mtl.pbr_metallic_roughness.base_color_texture.texture)
	{
		StringAuto uri(m_alloc);
		uri.sprintf("%s%s", m_texrpath.cstr(), getTextureUri(mtl.pbr_metallic_roughness.base_color_texture).cstr());

		xml = replaceAllString(
			xml, "%diff%", "<input shaderInput=\"diffTex\" value=\"" + std::string(uri.cstr()) + "\"/>");
		xml = replaceAllString(xml, "%diffTexMutator%", "1");
	}
	else
	{
		const F32* diffCol = &mtl.pbr_metallic_roughness.base_color_factor[0];

		xml = replaceAllString(xml,
			"%diff%",
			"<input shaderInput=\"diffColor\" value=\"" + std::to_string(diffCol[0]) + " " + std::to_string(diffCol[1])
				+ " " + std::to_string(diffCol[2]) + "\"/>");

		xml = replaceAllString(xml, "%diffTexMutator%", "0");
	}

	// Specular color (freshnel)
	{
		Vec3 specular;
		auto it = extras.find("specular");
		if(it != extras.getEnd())
		{
			StringListAuto tokens(m_alloc);
			tokens.splitString(it->toCString(), ' ');
			if(tokens.getSize() != 3)
			{
				ANKI_GLTF_LOGE("Wrong specular: %s", it->cstr());
				return Error::USER_DATA;
			}

			auto token = tokens.getBegin();
			ANKI_CHECK(token->toNumber(specular.x()));
			++token;
			ANKI_CHECK(token->toNumber(specular.y()));
			++token;
			ANKI_CHECK(token->toNumber(specular.z()));
		}
		else
		{
			specular = Vec3(0.04f);
		}

		xml = replaceAllString(xml,
			"%spec%",
			"<input shaderInput=\"specColor\" value=\"" + std::to_string(specular.x()) + " "
				+ std::to_string(specular.y()) + " " + std::to_string(specular.z()) + "\"/>");
		xml = replaceAllString(xml, "%specTexMutator%", "0");
	}

	// Identify metallic/roughness texture
	F32 constantMetaliness = -1.0f, constantRoughness = -1.0f;
	if(mtl.pbr_metallic_roughness.metallic_roughness_texture.texture)
	{
		const CString fname = getTextureUri(mtl.pbr_metallic_roughness.metallic_roughness_texture);

		ANKI_CHECK(identifyMetallicRoughnessTexture(fname, constantMetaliness, constantRoughness));
	}

	// Roughness
	if(mtl.pbr_metallic_roughness.metallic_roughness_texture.texture && constantRoughness < 0.0f)
	{
		StringAuto uri(m_alloc);
		uri.sprintf(
			"%s%s", m_texrpath.cstr(), getTextureUri(mtl.pbr_metallic_roughness.metallic_roughness_texture).cstr());

		xml = replaceAllString(
			xml, "%roughness%", "<input shaderInput=\"roughnessTex\" value=\"" + std::string(uri.cstr()) + "\"/>");

		xml = replaceAllString(xml, "%roughnessTexMutator%", "1");
	}
	else
	{
		const F32 roughness = (constantRoughness >= 0.0f)
								  ? constantRoughness * mtl.pbr_metallic_roughness.roughness_factor
								  : mtl.pbr_metallic_roughness.roughness_factor;

		xml = replaceAllString(
			xml, "%roughness%", "<input shaderInput=\"roughness\" value=\"" + std::to_string(roughness) + "\" />");

		xml = replaceAllString(xml, "%roughnessTexMutator%", "0");
	}

	// Metallic
	if(mtl.pbr_metallic_roughness.metallic_roughness_texture.texture && constantMetaliness < 0.0f)
	{
		StringAuto uri(m_alloc);
		uri.sprintf(
			"%s%s", m_texrpath.cstr(), getTextureUri(mtl.pbr_metallic_roughness.metallic_roughness_texture).cstr());

		xml = replaceAllString(
			xml, "%metallic%", "<input shaderInput=\"metallicTex\" value=\"" + std::string(uri.cstr()) + "\"/>");

		xml = replaceAllString(xml, "%metalTexMutator%", "1");
	}
	else
	{
		const F32 metalines = (constantMetaliness >= 0.0f)
								  ? constantMetaliness * mtl.pbr_metallic_roughness.metallic_factor
								  : mtl.pbr_metallic_roughness.metallic_factor;

		xml = replaceAllString(
			xml, "%metallic%", "<input shaderInput=\"metallic\" value=\"" + std::to_string(metalines) + "\" />");

		xml = replaceAllString(xml, "%metalTexMutator%", "0");
	}

	// Normal texture
	if(mtl.normal_texture.texture)
	{
		StringAuto uri(m_alloc);
		uri.sprintf("%s%s", m_texrpath.cstr(), getTextureUri(mtl.normal_texture).cstr());

		xml = replaceAllString(
			xml, "%normal%", "<input shaderInput=\"normalTex\" value=\"" + std::string(uri.cstr()) + "\"/>");

		xml = replaceAllString(xml, "%normalTexMutator%", "1");
	}
	else
	{
		xml = replaceAllString(xml, "%normal%", "");
		xml = replaceAllString(xml, "%normalTexMutator%", "0");
	}

	// Emissive texture
	if(mtl.emissive_texture.texture)
	{
		StringAuto uri(m_alloc);
		uri.sprintf("%s%s", m_texrpath.cstr(), getTextureUri(mtl.emissive_texture).cstr());

		xml = replaceAllString(
			xml, "%emission%", "<input shaderInput=\"emissiveTex\" value=\"" + std::string(uri.cstr()) + "\"/>");

		xml = replaceAllString(xml, "%emissiveTexMutator%", "1");
	}
	else
	{
		const F32* emissionCol = &mtl.emissive_factor[0];

		xml = replaceAllString(xml,
			"%emission%",
			"<input shaderInput=\"emission\" value=\"" + std::to_string(emissionCol[0]) + " "
				+ std::to_string(emissionCol[1]) + " " + std::to_string(emissionCol[2]) + "\"/>");

		xml = replaceAllString(xml, "%emissiveTexMutator%", "0");
	}

	// Subsurface
	{
		F32 subsurface;
		auto it = extras.find("subsurface");
		if(it != extras.getEnd())
		{
			ANKI_CHECK(it->toNumber(subsurface));
		}
		else
		{
			subsurface = 0.0f;
		}

		xml = replaceAllString(
			xml, "%subsurface%", "<input shaderInput=\"subsurface\" value=\"" + std::to_string(subsurface) + "\"/>");
	}

	// Height texture
	auto it = extras.find("height_map");
	if(it != extras.getEnd())
	{
		StringAuto uri(m_alloc);
		uri.sprintf("%s%s", m_texrpath.cstr(), it->cstr());

		xml = replaceAllString(xml,
			"%height%",
			"<input shaderInput=\"heightTex\" value=\"" + std::string(uri.cstr())
				+ "\"/>\n"
				  "\t\t<input shaderInput=\"heightMapScale\" value=\"0.05\"/>");

		xml = replaceAllString(
			xml, "%parallaxInput%", "<input shaderInput=\"modelViewMat\" builtin=\"MODEL_VIEW_MATRIX\"/>");

		xml = replaceAllString(xml, "%parallaxMutator%", "1");
	}
	else
	{
		xml = replaceAllString(xml, "%height%", "");
		xml = replaceAllString(xml, "%parallaxInput%", "");
		xml = replaceAllString(xml, "%parallaxMutator%", "0");
	}

	// Replace texture extensions with .anki
	xml = replaceAllString(xml, ".tga", ".ankitex");
	xml = replaceAllString(xml, ".png", ".ankitex");
	xml = replaceAllString(xml, ".jpg", ".ankitex");
	xml = replaceAllString(xml, ".jpeg", ".ankitex");

	// Write file
	File file;
	ANKI_CHECK(file.open(fname.toCString(), FileOpenFlag::WRITE));
	ANKI_CHECK(file.writeText("%s", xml.c_str()));

	return Error::NONE;
}

} // end namespace anki