// Copyright (C) 2009-2017, Panagiotis Christopoulos Charitos and contributors.
// All rights reserved.
// Code licensed under the BSD License.
// http://www.anki3d.org/LICENSE

#include "Exporter.h"
#include <iostream>

const char* MATERIAL_TEMPLATE = R"(<?xml version="1.0" encoding="UTF-8" ?>
<!-- This file is auto generated by ExporterMaterial.cpp -->
<material>
	<shaderProgram>%shaderProg%</shaderProgram>
	
	<inputs>
		<input>%diff%</input>
		<input>%spec%</input>
		<input>%roughness%</input>
		<input>%metallic%</input>
		%normal%
		<input>%emission%</input>
		<input>%subsurface%</input>
		%height%
	</inputs>
</material>
)";

void Exporter::exportMaterial(const aiMaterial& mtl) const
{
	aiString path;

	std::string name = getMaterialName(mtl);
	LOGI("Exporting material %s", name.c_str());

	std::string xml = MATERIAL_TEMPLATE;
	std::string prog_fname = "ms_";

	// Diffuse texture
	if(mtl.GetTextureCount(aiTextureType_DIFFUSE) > 0)
	{
		if(mtl.GetTexture(aiTextureType_DIFFUSE, 0, &path) == AI_SUCCESS)
		{
			std::string diffTex = m_texrpath + getFilename(path.C_Str());
			xml = replaceAllString(xml, "%diff%", "<shaderInput>diffTex</shaderInput><value>" + diffTex + "</value>");

			prog_fname += "difft_";
		}
		else
		{
			ERROR("Failed to retrieve texture");
		}
	}
	else
	{
		aiColor3D diffCol = {0.0, 0.0, 0.0};
		mtl.Get(AI_MATKEY_COLOR_DIFFUSE, diffCol);

		xml = replaceAllString(xml,
			"%diff%",
			"<shaderInput>diffCol</shaderInput><value>" + std::to_string(diffCol[0]) + " " + std::to_string(diffCol[1])
				+ " "
				+ std::to_string(diffCol[2])
				+ "</value>");

		prog_fname += "diffc_";
	}

	// Specular color
	if(mtl.GetTextureCount(aiTextureType_SPECULAR) > 0)
	{
		if(mtl.GetTexture(aiTextureType_SPECULAR, 0, &path) == AI_SUCCESS)
		{
			std::string specTex = m_texrpath + getFilename(path.C_Str());
			xml = replaceAllString(xml, "%spec%", "<shaderInput>specTex</shaderInput><value>" + specTex + "</value>");

			prog_fname += "spect_";
		}
		else
		{
			ERROR("Failed to retrieve texture");
		}
	}
	else
	{
		aiColor3D specCol = {0.0, 0.0, 0.0};
		mtl.Get(AI_MATKEY_COLOR_SPECULAR, specCol);

		xml = replaceAllString(xml,
			"%spec%",
			"<shaderInput>specCol</shaderInput><value>" + std::to_string(specCol[0]) + " " + std::to_string(specCol[1])
				+ " "
				+ std::to_string(specCol[2])
				+ "</value>");

		prog_fname += "specc_";
	}

	// Roughness
	if(mtl.GetTextureCount(aiTextureType_SHININESS) > 0)
	{
		if(mtl.GetTexture(aiTextureType_SHININESS, 0, &path) == AI_SUCCESS)
		{
			std::string shininessTex = m_texrpath + getFilename(path.C_Str());
			xml = replaceAllString(
				xml, "%roughness%", "<shaderInput>roughnessTex</shaderInput><value>" + shininessTex + "</value>");

			prog_fname += "rought_";
		}
		else
		{
			ERROR("Failed to retrieve texture");
		}
	}
	else
	{
		float shininess = 0.0;
		mtl.Get(AI_MATKEY_SHININESS, shininess);
		const float MAX_SHININESS = 511.0;
		shininess = std::min(MAX_SHININESS, shininess);
		if(shininess > MAX_SHININESS)
		{
			LOGW("Shininness exceeds %f", MAX_SHININESS);
		}

		shininess = shininess / MAX_SHININESS;

		xml = replaceAllString(
			xml, "%roughness%", "<shaderInput>roughness</shaderInput><value>" + std::to_string(shininess) + "</value>");

		prog_fname += "roughc_";
	}

	// Metallic texture
	if(mtl.GetTextureCount(aiTextureType_REFLECTION) > 0)
	{
		if(mtl.GetTexture(aiTextureType_REFLECTION, 0, &path) == AI_SUCCESS)
		{
			std::string metallicTex = m_texrpath + getFilename(path.C_Str());
			xml = replaceAllString(
				xml, "%metallic%", "<shaderInput>metallicTex</shaderInput><value>" + metallicTex + "</value>");

			prog_fname += "metalt_";
		}
		else
		{
			ERROR("Failed to retrieve texture");
		}
	}
	else
	{
		float metallic = 0.0;
		if(mtl.mAnKiProperties.find("metallic") != mtl.mAnKiProperties.end())
		{
			metallic = std::stof(mtl.mAnKiProperties.at("metallic"));
		}

		xml = replaceAllString(
			xml, "%metallic%", "<shaderInput>metallic</shaderInput><value>" + std::to_string(metallic) + "</value>");

		prog_fname += "metalc_";
	}

	// Normal texture
	if(mtl.GetTextureCount(aiTextureType_NORMALS) > 0)
	{
		if(mtl.GetTexture(aiTextureType_NORMALS, 0, &path) == AI_SUCCESS)
		{
			std::string normTex = m_texrpath + getFilename(path.C_Str());
			xml = replaceAllString(
				xml, "%normal%", "<input><shaderInput>normalTex</shaderInput><value>" + normTex + "</value></input>");

			prog_fname += "normalt_";
		}
		else
		{
			ERROR("Failed to retrieve texture");
		}
	}
	else
	{
		xml = replaceAllString(xml, "%normal%", "");
		prog_fname += "normal0_";
	}

	// Emissive texture
	if(mtl.GetTextureCount(aiTextureType_EMISSIVE) > 0)
	{
		if(mtl.GetTexture(aiTextureType_EMISSIVE, 0, &path) == AI_SUCCESS)
		{
			std::string emissiveTex = m_texrpath + getFilename(path.C_Str());
			xml = replaceAllString(
				xml, "%emission%", "<shaderInput>emissionTex</shaderInput><value>" + emissiveTex + "</value>");

			prog_fname += "emist_";
		}
		else
		{
			ERROR("Failed to retrieve texture");
		}
	}
	else
	{
		aiColor3D emissionCol = {0.0, 0.0, 0.0};
		mtl.Get(AI_MATKEY_COLOR_EMISSIVE, emissionCol);

		xml = replaceAllString(xml,
			"%emission%",
			"<shaderInput>emission</shaderInput><value>" + std::to_string(emissionCol[0]) + " "
				+ std::to_string(emissionCol[1])
				+ " "
				+ std::to_string(emissionCol[2])
				+ "</value>");

		prog_fname += "emisc_";
	}

	// Subsurface
	{
		float subsurface = 0.0;
		if(mtl.mAnKiProperties.find("subsurface") != mtl.mAnKiProperties.end())
		{
			subsurface = std::stof(mtl.mAnKiProperties.at("subsurface"));
		}

		xml = replaceAllString(xml,
			"%subsurface%",
			"<shaderInput>subsurface</shaderInput><value>" + std::to_string(subsurface) + "</value>");

		prog_fname += "subsc_";
	}

	// Height texture
	if(mtl.GetTextureCount(aiTextureType_DISPLACEMENT) > 0)
	{
		if(mtl.GetTexture(aiTextureType_DISPLACEMENT, 0, &path) == AI_SUCCESS)
		{
			std::string dispTex = m_texrpath + getFilename(path.C_Str());
			xml = replaceAllString(xml,
				"%height%",
				"<input><shaderInput>heightTex</shaderInput><value>" + dispTex
					+ "</value></input>\n"
					  "\t\t<input><shaderInput>heightMapScale</input><value>0.05</value></input>");

			prog_fname += "par1";
		}
		else
		{
			ERROR("Failed to retrieve texture");
		}
	}
	else
	{
		xml = replaceAllString(xml, "%height%", "");
		prog_fname += "par0";
	}

	xml = replaceAllString(xml, "%shaderProg%", m_progrpath + prog_fname + ".ankiprog");

	// Replace texture extensions with .anki
	xml = replaceAllString(xml, ".tga", ".ankitex");
	xml = replaceAllString(xml, ".png", ".ankitex");
	xml = replaceAllString(xml, ".jpg", ".ankitex");
	xml = replaceAllString(xml, ".jpeg", ".ankitex");

	// Open and write file
	std::fstream file;
	file.open(m_outputDirectory + name + ".ankimtl", std::ios::out);
	file << xml;
}
