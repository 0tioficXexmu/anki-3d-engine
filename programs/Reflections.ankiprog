<!-- 
Copyright (C) 2009-2018, Panagiotis Christopoulos Charitos and contributors.
All rights reserved.
Code licensed under the BSD License.
http://www.anki3d.org/LICENSE
-->
<shaderProgram>
	<mutators>
		<mutator name="VARIANT" values="0 1"/>
	</mutators>

	<shaders>
		<shader type="comp">
			<inputs>
				<input name="FB_SIZE" type="uvec2" const="1"/>
				<input name="WORKGROUP_SIZE" type="uvec2" const="1"/>
				<input name="MAX_STEPS" type="uint" const="1"/>
				<input name="LIGHT_BUFFER_MIP_COUNT" type="uint" const="1"/>
				<input name="HIZ_MIP_COUNT" type="uint" const="1"/>
			</inputs>

			<source><![CDATA[
#define NO_HIZ 0
	
#include "shaders/Functions.glsl"
#include "shaders/Pack.glsl"

layout(local_size_x = WORKGROUP_SIZE.x, local_size_y = WORKGROUP_SIZE.y, local_size_z = 1) in;

layout(ANKI_TEX_BINDING(0, 0)) uniform sampler2D u_gbufferRt1;
layout(ANKI_TEX_BINDING(0, 1)) uniform sampler2D u_gbufferRt2;
layout(ANKI_TEX_BINDING(0, 2)) uniform sampler2D u_hizRt;
layout(ANKI_TEX_BINDING(0, 3)) uniform sampler2D u_lightBufferRt;

layout(ANKI_IMAGE_BINDING(0, 0)) writeonly uniform image2D u_out;

layout(ANKI_UBO_BINDING(0, 0), std140, row_major) uniform u0_
{
	mat4 u_projMat;
	mat4 u_invViewProjMat;
	mat4 u_invProjMat;
	mat4 u_viewMat;
	vec4 u_camPosNear;
	vec4 u_unprojParams;
};

#define u_camPos u_camPosNear.xyz
#define u_near u_camPosNear.w
#define u_normalMat mat3(u_viewMat)

float unprojZ(float depth)
{
	return u_unprojParams.z / (u_unprojParams.w + depth);
}

vec4 returnSslrColor(vec3 raySample, float factor, float roughness)
{
	vec2 ndc = abs(UV_TO_NDC(raySample.xy));
	float contribution = max(ndc.x, ndc.y);
	contribution = 1.0 - contribution * contribution;
	contribution *= factor;

	float lod = float(LIGHT_BUFFER_MIP_COUNT - 1u) * roughness;
	vec3 color = textureLod(u_lightBufferRt, raySample.xy, lod).rgb;
	return vec4(color, contribution);
}

// Note: All calculations in view space
vec4 doSslr(vec3 r, vec3 n, vec3 viewPos, vec2 uv, float depth, float roughness)
{
	const ivec2 HIZ_SIZE = ivec2(FB_SIZE) >> 1;
	vec3 p0 = viewPos;

	// Check for view facing reflections [sakibsaikia]
	vec3 viewDir = normalize(viewPos);
	float cameraFacingReflectionAttenuation = 1.0 - smoothstep(0.25, 0.5, dot(-viewDir, r));
	if(cameraFacingReflectionAttenuation <= 0.0)
	{
		return vec4(0.0);
	}

	// Compute an end point p1. This point is supposed to fall in front of the near plane. u_near is a bit bigger than
	// the actual near.
	vec3 p1 = p0 + r * (-p0.z - u_near);

	// Start point
	vec3 start = vec3(uv, depth);

	// Project end point
	vec4 end4 = u_projMat * vec4(p1, 1.0);
	vec3 end = end4.xyz / end4.w;
	end.xy = NDC_TO_UV(end.xy);

	// Compute the ray
	vec3 ray = end - start;
#if NO_HIZ
	vec2 texelDims = abs(ray.xy) * vec2(HIZ_SIZE);
#else
	vec2 texelDims = abs(ray.xy) * vec2(HIZ_SIZE >> (HIZ_MIP_COUNT - 1u));
#endif
	float stepSize = length(ray.xy) / max(texelDims.x, texelDims.y);
	ray = normalize(ray);
	if(ray.x == 0.0)
	{
		ray.x = EPSILON;
	}
	if(ray.y == 0.0)
	{
		ray.y = EPSILON;
	}

	// Iterate
#if NO_HIZ
	for(uint step = 4u; step < MAX_STEPS; step += 1u)
	{
		vec3 raySample = start + ray * (float(step) * stepSize);

		// Check if it's out of the view
		if(raySample.x <= 0.0 || raySample.y <= 0.0 || raySample.x >= 1.0 || raySample.y >= 1.0)
		{
			return vec4(0.0);
		}

		float depth = textureLod(u_hizRt, raySample.xy, float(HIZ_MIP_TO_USE)).r;

		float diff = raySample.z - depth;
		if(diff >= 0.0)
		{
			return returnSslrColor(raySample, cameraFacingReflectionAttenuation, roughness);
		}
	}
#else
	int mipLevel = int(HIZ_MIP_COUNT - 1);
	vec3 raySample = start + ray * stepSize;
	uint stepCount = 0U;
	while(mipLevel > -1 && stepCount < MAX_STEPS)
	{
		// Step through the cell
		{
			ivec2 mipSize = ivec2(HIZ_SIZE) >> mipLevel;

			// Move the ray to texture space
			vec2 mipCellIndex = raySample.xy * vec2(mipSize);

			// Find the closest cell's edge to the ray direction
			vec2 closestCellEdgeUv;
			closestCellEdgeUv.x = (ray.x > 0.0) ? ceil(mipCellIndex.x) + 0.1 : floor(mipCellIndex.x) - 0.1;
			closestCellEdgeUv.y = (ray.y > 0.0) ? ceil(mipCellIndex.y) + 0.1 : floor(mipCellIndex.y) - 0.1;
			closestCellEdgeUv /= vec2(mipSize);

			// Intersect the ray that starts from the start with direction ray and the 2 lines:
			// x = closestCellEdgeUv.x
			// y = closestCellEdgeUv.y
			vec2 t;
			t.x = (closestCellEdgeUv.x - raySample.x) / ray.x;
			t.y = (closestCellEdgeUv.y - raySample.y) / ray.y;

			// Pick the cell intersection that is closer, and march to that cell
			float mint = min(t.x, t.y);
			raySample += mint * ray;
		}

		// Check if it's out of the view
		if(raySample.x <= 0.0 || raySample.y <= 0.0 || raySample.x >= 1.0 || raySample.y >= 1.0)
		{
			return vec4(0.0);
		}

		// Get the viewspace Z from the depth buffer
		float depth = textureLod(u_hizRt, raySample.xy, float(mipLevel)).r;

		if(raySample.z > depth)
		{
			// If we intersected, pull back the ray to the point of intersection (for that miplevel)
			float t = (raySample.z - depth) / ray.z;
			raySample -= ray * t;

			// And, then perform successive test on the next lower mip level.
			// Once we've got a valid intersection with mip 0, we've found our intersection point
			--mipLevel;
		}

		++stepCount;
	}

	if(mipLevel < 0)
	{
		return returnSslrColor(raySample, cameraFacingReflectionAttenuation, roughness);
	}
#endif

	return vec4(0.0);
}

void main()
{
	uvec2 realInvocationId = gl_GlobalInvocationID.xy;
	realInvocationId.x *= 2u;
#if VARIANT == 0
	if((realInvocationId.y & 1u) == 0u)
#else
	if((realInvocationId.y & 1u) == 1u)
#endif
	{
		realInvocationId.x += 1u;
	}

	if(realInvocationId.x >= FB_SIZE.x || realInvocationId.y >= FB_SIZE.y)
	{
		// Skip threads outside the writable image
		return;
	}

	vec2 uv = vec2(realInvocationId) / vec2(FB_SIZE);

	// Get normal
	vec3 worldNormal;
	readNormalFromGBuffer(u_gbufferRt2, uv, worldNormal);

	// Get roughness
	float roughness;
	vec3 specular;
	readRoughnessSpecularFromGBuffer(u_gbufferRt1, uv, roughness, specular);

	// Get view pos
	float depth = textureLod(u_hizRt, uv, 0.0).r;
	vec4 viewPos4 = u_invProjMat * vec4(UV_TO_NDC(uv), depth, 1.0);
	vec3 viewPos = viewPos4.xyz / viewPos4.w;

	// Do SSLR
	vec3 viewDir = normalize(viewPos);
	vec3 viewNormal = u_normalMat * worldNormal;
	vec3 reflVec = reflect(viewDir, viewNormal);

	vec4 sslr = doSslr(reflVec, viewNormal, viewPos, uv, depth, roughness);
	float sslrFactor = sslr.w;
	vec3 sslrCol = sslr.xyz;

	// Write it
	imageStore(u_out, ivec2(realInvocationId), vec4(sslrCol * sslrFactor, 0.0));
}
			]]></source>
		</shader>
	</shaders>
</shaderProgram>
