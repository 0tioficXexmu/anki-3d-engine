<!-- 
Copyright (C) 2009-2018, Panagiotis Christopoulos Charitos and contributors.
All rights reserved.
Code licensed under the BSD License.
http://www.anki3d.org/LICENSE
-->
<shaderProgram>
	<shaders>
		<shader type="comp">
			<inputs>
				<input name="FB_SIZE" type="uvec2" const="1"/>
				<input name="WORKGROUP_SIZE" type="uvec2" const="1"/>
				<input name="MAX_STEPS" type="uint" const="1"/>
				<input name="LIGHT_BUFFER_MIP_COUNT" type="uint" const="1"/>
			</inputs>

			<source><![CDATA[
#include "shaders/Functions.glsl"
#include "shaders/Pack.glsl"

layout(local_size_x = WORKGROUP_SIZE.x, local_size_y = WORKGROUP_SIZE.y, local_size_z = 1) in;

layout(ANKI_TEX_BINDING(0, 0)) uniform sampler2D u_gbufferRt1;
layout(ANKI_TEX_BINDING(0, 1)) uniform sampler2D u_gbufferRt2;
layout(ANKI_TEX_BINDING(0, 2)) uniform sampler2D u_depthRt;
layout(ANKI_TEX_BINDING(0, 3)) uniform sampler2D u_lightBufferRt;

layout(ANKI_IMAGE_BINDING(0, 0)) writeonly uniform image2D u_out;

layout(ANKI_UBO_BINDING(0, 0), std140, row_major) uniform u0_
{
	mat4 u_projMat;
	mat4 u_invViewProjMat;
	mat4 u_invProjMat;
	mat4 u_viewMat;
	vec4 u_camPosNear;
};

#define u_camPos u_camPosNear.xyz
#define u_near u_camPosNear.w
#define u_normalMat mat3(u_viewMat)

vec4 doSslr(vec3 r, vec3 worldPos, vec2 uv)
{
	// This func is working in view space
	vec3 p0 = (u_viewMat * vec4(worldPos, 1.0)).xyz;
	r = u_normalMat * r;

	// Compute an end point p1. This point is supposed to fall in front of the near plane. u_near is a bit bigger than
	// the actual near.
	vec3 p1 = p0 + r * (-p0.z - u_near);

	// Project the starting and end points
	vec2 start = uv;
	vec4 end4 = u_projMat * vec4(p1, 1.0);
	vec2 end = NDC_TO_UV(end4.xy / end4.w);

	// Compute the step size
	vec2 dir = end - start;
	vec2 texelDims = abs(dir * FB_SIZE); // TODO maybe it should be FB_SIZE/2
	float stepSize = length(dir) / max(texelDims.x, texelDims.y);
	dir = normalize(dir);

	// Iterate
	for(float i = 1.0; i < float(MAX_STEPS); i += 1.0)
	{
		vec2 newUv = start + dir * (i * stepSize);

		// Check if it's out of the view
		if(newUv.x < 0.0 || newUv.y < 0.0 || newUv.x > 1.0 || newUv.y > 1.0)
		{
			return vec4(0.0);
		}

		vec2 ndc = UV_TO_NDC(newUv);

		// 'a' is ray that passes through the eye and into ndc
		vec4 a4 = u_invProjMat * vec4(ndc, 1.0, 1.0);
		vec3 a = a4.xyz / a4.w;
		a = normalize(a);
		
		// Compute the intersection between 'a' (before normalization) and r
		// 'k' is the value to multiply to 'a' to get the intersection
		// c0 = cross(a, r);
		// c1 = cross(p0, r);
		// k = c1.x / c0.x; and the optimized:
		vec2 tmpv2 = a.yz * r.zy;
		float c0x = tmpv2.x - tmpv2.y;
		tmpv2 = p0.yz * r.zy;
		float c1x = tmpv2.x - tmpv2.y;
		float k = c1x / c0x;

		float intersectionZ = a.z * k;

		// Read depth and get view space Z
		float depth = textureLod(u_depthRt, newUv, 0.0).r;
		vec4 newViewPos4 = u_invProjMat * vec4(ndc, depth, 1.0);
		float newViewPosZ = newViewPos4.z / newViewPos4.w;

		// Compare depths
		float zDiff = newViewPosZ - intersectionZ;

		if(zDiff > 0.1)
		{
			float contribution = sin(length(ndc) * PI);

			float roughness;
			vec3 specular;
			readRoughnessSpecularFromGBuffer(u_gbufferRt1, newUv, roughness, specular);

			float lod = float(LIGHT_BUFFER_MIP_COUNT - 1u) * roughness;
			vec3 color = textureLod(u_lightBufferRt, newUv, lod).rgb;
			return vec4(color, contribution);
		}
	}

	return vec4(0.0);
}

void main()
{
	if(gl_GlobalInvocationID.x >= FB_SIZE.x || gl_GlobalInvocationID.y >= FB_SIZE.y)
	{
		// Skip threads outside the writable image
		return;
	}

	vec2 uv = vec2(gl_GlobalInvocationID.xy) / vec2(FB_SIZE);

	// Get normal
	vec3 normal;
	readNormalFromGBuffer(u_gbufferRt2, uv, normal);

	// Get world pos
	float depth = textureLod(u_depthRt, uv, 0.0).r;
	vec4 worldPos4 = u_invViewProjMat * vec4(UV_TO_NDC(uv), depth, 1.0);
	vec3 worldPos = worldPos4.xyz / worldPos4.w;

	// Compute reflection vec
	vec3 viewDir = normalize(worldPos - u_camPos);
	vec3 reflVec = reflect(viewDir, normal);

	// Do SSLR
	vec4 sslr = doSslr(reflVec, worldPos, uv);
	float sslrFactor = sslr.w;
	vec3 sslrCol = sslr.xyz;

	// Write it
	imageStore(u_out, ivec2(gl_GlobalInvocationID.xy), vec4(sslrCol, 0.0));
}
			]]></source>
		</shader>
	</shaders>
</shaderProgram>
