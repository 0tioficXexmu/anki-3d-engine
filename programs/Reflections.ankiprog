<!-- 
Copyright (C) 2009-2018, Panagiotis Christopoulos Charitos and contributors.
All rights reserved.
Code licensed under the BSD License.
http://www.anki3d.org/LICENSE
-->
<shaderProgram>
	<shaders>
		<shader type="comp">
			<inputs>
				<input name="FB_SIZE" type="uvec2" const="1"/>
				<input name="WORKGROUP_SIZE" type="uvec2" const="1"/>
				<input name="MAX_STEPS" type="uint" const="1"/>
				<input name="LIGHT_BUFFER_MIP_COUNT" type="uint" const="1"/>
			</inputs>

			<source><![CDATA[
#include "shaders/Functions.glsl"
#include "shaders/Pack.glsl"

layout(local_size_x = WORKGROUP_SIZE.x, local_size_y = WORKGROUP_SIZE.y, local_size_z = 1) in;

layout(ANKI_TEX_BINDING(0, 1)) uniform sampler2D u_gbufferRt1;
layout(ANKI_TEX_BINDING(0, 2)) uniform sampler2D u_gbufferRt2;
layout(ANKI_TEX_BINDING(0, 3)) uniform sampler2D u_depthRt;
layout(ANKI_TEX_BINDING(0, 4)) uniform sampler2D u_lightBufferRt;

layout(ANKI_IMAGE_BINDING(0, 0)) writeonly uniform image2D u_out;

layout(ANKI_UBO_BINDING(0, 0), std140, row_major) uniform u0_
{
	mat4 u_prevViewProjMatMulInvViewProjMat;
};

// http://paulbourke.net/geometry/pointlineplane/
// Line segment A is p1, p2. Line segment B is p3, p4
vec3 lineSegmentsIntersection(vec3 p1, vec3 p2, vec3 p3, vec3 p4)
{
	vec3 p13 = p1 - p3;
	vec3 p43 = p4 - p3;

	float d1343 = dot(p13, p43);
	float d4321 = dot(p43, p21);
	float d1321 = dot(p13, p21);
	float d4343 = dot(p43, p43);
	float d2121 = dot(p21, p21);

	float denom = d2121 * d4343 - d4321 * d4321;
	if(denom == 0.0)
	{
		denom = EPSILON;
	}

	float numer = d1343 * d4321 - d1321 * d4343;

	float mua = numer / denom;

	vec3 result = p1 + mua * p21;
	return result;
}

vec3 doSslr(vec3 r, vec3 worldPos, vec2 uv, out float contribution)
{
	vec3 p0 = worldPos;
	contribution = 0.0;

	// Compute an end point p1 that is p1 = p0 + t*r. p1 will lie in the near plane.
	// The code is the same used to compute the intersection of a ray to a plane.
	// NOTE: The nearPlane is a bit in front of the real near plane. We do that to be able to project p1 without 
	//       problems
	vec3 p1;
	{
		float d = dot(nearPlane.xyz, p0) - nearPlane.w;
		float a = dot(nearPlane.xyz, r);

		float s;
		if(d > 0.0 && a < 0.0)
		{
			// We have intersection, compute the intersection point
			s = -d / a;
		}
		else
		{
			// No intersection, create a correct point
			s = 1000.0;
		}

		p1 = p0 + s * r;
	}

	// Project the starting and end points
	vec2 start = uv;
	vec4 end4 = u_viewProjMat * vec4(p1, 1.0);
	vec2 end = NDC_TO_UV(end4.xy / end4.w);

	// Compute the step size
	vec2 dir = end - start;
	float stepSize = max(dir.x, dir.y);
	dir = normalize(dir);

	// Iterate
	for(float i = 1.0; i < float(MAX_STEPS); i += 1.0)
	{
		vec2 newUv = start + dir * (i * stepSize);

		// Check if it's out of the view
		if(newUv.x < 0.0 || newUv.y < 0.0 || newUv.x > 1.0 || newUv.y > 1.0)
		{
			return vec3(0.0);
		}

		vec2 ndc = UV_TO_NDC(newUv);

		// 'a' is ray that passes through the eye and into ndc
		vec4 a4 = u_invViewProjMat * vec4(ndc, 1.0, 1.0);
		vec3 a = a4.xyz / a4.w;
		
		// Compute the intersection between line segment (camera_pos, a) and line segment (p0, p1)
		vec3 intersection = lineSegmentsIntersection(u_camPos, a, p0, p1);

		// Project the intersection
		vec4 intersection4 = u_viewProjMat * vec4(intersection, 1.0);
		float intersectionDepth = intersection4.z / intersection4.w;

		// Read depth
		float depth = textureLod(u_depthRt, newUv, 0.0).r;

		// Compare depths
		float diffDepth = depth - intersectionDepth;

		if(diffDepth > EPSILON)
		{
			contribution = sin(length(ndc) * PI);

			float roughness;
			vec3 specular;
			readRoughnessSpecularFromGBuffer(u_gbufferRt1, newUv, roughness, specular);

			float lod = float(LIGHT_BUFFER_MIP_COUNT - 1u) * roughness;
			vec3 color = textureLod(u_lightBufferRt, newUv, lod).rgb;
			return color;
		}
	}

	return vec3(0.0);
}

void main()
{
	vec2 uv = vec2(gl_GlobalInvocationID.xy) / vec2(FB_SIZE);

	// Get normal
	vec3 normal;
	readNormalFromGBuffer(u_gbufferRt2, uv, normal);

	// Get world pos
	float depth = textureLod(u_depthRt, uv, 0.0).r;
	vec4 worldPos4 = u_invViewProjMat * vec4(UV_TO_NDC(uv), depth, 1.0);
	vec3 worldPos = worldPos4.xyz / worldPos4.w;

	// Compute reflection vec
	vec4 viewDir = normalize(worldPos - u_camPos);
	vec3 refl = reflect(viewDir, normal);

	// Do SSLR
	float sslrFactor;
	vec3 sslrCol = doSslr(r, worldPos, uv, sslrFactor);

	// Write it
	imageStore(u_out, gl_GlobalInvocationID.xy, vec4(sslrCol, 0.0));
}
			]]></source>
		</shader>
	</shaders>
</shaderProgram>
